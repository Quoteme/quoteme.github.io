[
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here is a small list of projects I have worked on. Most are open source and can be found on my GitHub.\n\n\n\n\n\n\n\n\n\nMy math stuff\n\n\n\n\n\n\n\nTop2Man\n\n\n\n\n\n\n\nImg2String\n\n\n\n\n\n\n\n\n\nWebGLCS\n\n\n\n\n\n\n\nDimensionCrusher\n\n\n\n\n\n\n\nComplexGrapher\n\n\n\n\n\n\n\n\n\nFluchtpunkt3D\n\n\n\n\n\n\n\nKnowHowComputer\n\n\n\n\n\n\n\nRelic Hunter Zero (STEAM)\n\n\n\n\n\n\n\n\n\nMatrix Visualizer\n\n\n\n\n\n\n\nMore\n\n\n\n\n\n\n\n\nMy math stuff\nTop2Man\nImg2String\nWebGLCS\nDimensionCrusher\nComplexGrapher\nFluchtpunkt3D\nKnowHowComputer\nRelic Hunter Zero (STEAM)\nMatrix Visualizer\nMore"
  },
  {
    "objectID": "posts/theorem_provers_exam/index.html",
    "href": "posts/theorem_provers_exam/index.html",
    "title": "Automated theorem proving",
    "section": "",
    "text": "WARNING: This is a work in progress. I am currently writing this article and it is not finished yet. I will update it regularly and remove this warning once it is finished."
  },
  {
    "objectID": "posts/theorem_provers_exam/index.html#introduction",
    "href": "posts/theorem_provers_exam/index.html#introduction",
    "title": "Automated theorem proving",
    "section": "Introduction",
    "text": "Introduction\nIf you are a programmer, most likely you know that feeling you get when you work on your code for too long, that maybe, however unlikely, there is a bug in your code. You have tested it, you have written unit tests, but still, you are not sure. You are not sure if your code is correct. This is where formal verification comes in. Formal verification is the process of proving that a program is correct. This can be done in many ways, but one of the most interesting ways is automated theorem proving. In this article, I will provide a glimpse into automated theorem proving and show you how to use the Lean4 programming language to prove theorems. This is not really intended as an introduction to Lean4 or automated theorem proving, but rather as a demonstration of what I learned after half holding a seminar about it, attending half a year of a course about it at the university of Düsseldorf and particiating at the conference Lean for the Curious Mathematician 2023."
  },
  {
    "objectID": "posts/theorem_provers_exam/index.html#from-functional-programming-to-automated-theorem-proving",
    "href": "posts/theorem_provers_exam/index.html#from-functional-programming-to-automated-theorem-proving",
    "title": "Automated theorem proving",
    "section": "From functional programming to automated theorem proving",
    "text": "From functional programming to automated theorem proving\nLean4 is a functional programming language. This means that it is a programming language that is based on the \\(\\lambda\\)-calculus. The \\(\\lambda\\)-calculus is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. In Lean4, we write programs by defining functions, composing them in clever ways and finally applying them to specific arguemnts. In this regard, Lean4 is very similar to Haskell, about which I held a talk a year ago.\nBy enriching the \\(\\lambda\\)-calculus with a sufficiently strong type system like in Lean4, we can use the resulting programming language to write programs that are provably correct. The foundation of this is the Curry-Howard correspondence, whose motto is “propositions as types, proofs as terms”. In \\(\\lambda\\)-calculus, terms are well-defined mathematical objects as are types.\nA quick example of the power that a strong type system provides us with would be the following Lean4 code snippet:\ndef swap {α β : Type} (p : α × β) : β × α := (p.snd, p.fst)\n\ntheorem swap_swap {α β : Type} (p : α × β) : swap (swap p) = p :=\n  match p with\n  | (a, b) =&gt; rfl\n\n\nHere we define a function swap that swaps the elements of a pair. We then prove that swap is involutive, i.e. that swap (swap p) = p for all pairs p. The theorem keyword is used to define a theorem, but is just syntactic sugar for defining a function that represents a proof. Notice that we state our theorem using Lean4’s type system and then provide a proof using Lean4’s programming language. The proof is verified by the Lean4 compiler, which checks if each step in the program has valid types. If we were to change the proof to the following:\ntheorem swap_swap {α β : Type} (p : α × β) : swap (swap p) ≠ p :=\n  match p with\n  | (a, b) =&gt; rfl\n\n\nThe Lean4 compiler would throw the following error regarding the rlf function:\ntype mismatch\n  rfl\nhas type\n  ?m.149 = ?m.149 : Prop\nbut is expected to have type\n  swap (swap (a, b)) ≠ (a, b) : Prop\n\n\nNotice that the error message is very helpful (if you know how to decode it) and it tells us exactly what went wrong. It tells us that rfl (the reflexivity axiom, which states that for all \\(a\\), we have \\(a=a\\)) has type ?m.149 = ?m.149 : Prop, but the term we provided has type swap (swap (a, b)) ≠ (a, b) : Prop. We did not get this error message previously, because previously we wanted to show that swap (swap p) = p, which we did by unfolding the definition of swap using the match keyword and then using the rfl function to show that (a,b) = (a,b). This last step is where everything went wrong in the second proof. After unpacking we get swap (swap (a, b)) = (a, b), and now by applying rfl we get a term (a,b) = (a,b), which is not what we wanted to show. We wanted to show that swap (swap (a, b)) ≠ (a, b), which is not true, and thus we get a type error.\n\nUntyped \\(\\lambda\\)-calculus\nLet \\(V = \\{x,y,z, \\dots\\}\\) be a set, which we call the set of variables and let \\(K = \\{\\a,\\b,\\f,\\g, \\dots\\}\\) be a set, which we call the set of constants. We can now define the set of terms \\(\\Lambda\\) inductively as follows:\n\n\n\n\n\n\n\nRule\nName\n\n\n\n\nIf \\(x \\in V\\), then \\(x \\in \\Lambda\\)\nVariable\n\n\nIf \\(\\f \\in K\\), then \\(\\f \\in \\Lambda\\)\nConstant\n\n\nIf \\(s,t \\in \\Lambda\\), then \\((st) \\in \\Lambda\\)\nApplication\n\n\nIf \\(x \\in V\\) and \\(t \\in \\Lambda\\), then \\((\\lambda x.t) \\in \\Lambda\\)\nAbstraction\n\n\n\nUsing the notation of the Backus–Naur form, we can define \\(\\Lambda\\) succinctly as follows:\n\\[\n\\Lambda ::= V \\mid K \\mid \\Lambda \\Lambda \\mid \\lambda V.\\Lambda\n\\]\nThis strongly resembles the syntax of Lean4 and also that of Haskell.\n\n\nSimply typed \\(\\lambda\\)-calculus\nIn the simply typed \\(\\lambda\\)-calculus, we enrich the untyped \\(\\lambda\\)-calculus with a type system. We define the set of types \\(\\T\\) inductively using a set of base types \\(\\T_0\\) as follows:\n\nIf \\(A \\in \\T_0\\), then \\(A \\in \\T\\)\nIf \\(A,B \\in \\T\\), then \\(A \\to B \\in \\T\\)\n\nUsing the notation of the Backus–Naur form again, we can define \\(\\T\\) succinctly as follows:\n\\[\n\\T ::= \\T_0 \\mid \\T \\to \\T\n\\]\nUsing the set of types \\(\\T\\), we can now define the set of typed terms \\(\\Lambda_\\T\\) inductively using the Backus–Naur form as follows:\n\\[\n\\begin{align*}\n\\Lambda_\\T &::= V \\mid K \\mid \\Lambda_\\T \\Lambda_\\T \\mid \\lambda V:\\T.\\Lambda_\\T \\\\\n           & \\text{where } \\\\\n           & V \\text{ is the infinite set of variables } \\\\\n           & K \\text{ is the set of constants } \\\\\n\\end{align*}\n\\]\n\n\nType inference\nUsing typed \\(\\lambda\\)-calculus as a basis for our programming language, we can now associate a type with each valid term. For example:\n\\[\n\\begin{align*}\n(+1) &= \\lambda x : \\N \\to \\N. x+1 & : \\N \\to \\N \\\\\n\\text{hello} &= \\text{IO.println} \\, \\text{\"Hello, world!\"} & : \\text{IO} \\, \\text{Unit} \\\\\n\\f &= \\lambda \\g : \\alpha \\to \\alpha. g \\, g & : (\\alpha \\to \\alpha) \\to \\alpha \\to \\alpha\n\\end{align*}\n\\]\nNot all terms have a type, however. For example, assume \\(\\a, \\b \\in K\\) are some constants. We say, that our context \\(\\Gamma\\) consists of \\(\\a, \\b : \\kappa\\), denoted as \\(\\Gamma, \\, \\a, \\b : \\kappa\\), say in the context \\(\\Gamma\\), it holds that \\(\\a, \\b\\) are of type \\(\\kappa\\). Then the term \\(\\a \\b\\) does not have a type, because we cannot infer a type for \\(\\a\\) and \\(\\b\\), as we cannot apply \\(\\a\\) to \\(\\b\\).\nLean4 and other programming languages with sufficiently strong type systems can infer the type of a term. This is called type inference. For example, in Lean4, we can write the following code:\ndef f x := x + 1\n\n\nThis snippet defines a function f that takes an argument x and returns x + 1. We did not specify the type of x, but Lean4 can infer that x is of type ℕ, because we used 1, which is of type ℕ, in the expression x + 1 and if the second parameter of the + function is of type ℕ, then the first parameter must also be of type ℕ (although this is not true in general, but we do not care about this here).\nImplicitly we used the context \\(\\Gamma\\), such that 1:ℕ. To achieve a fully sound and rigorous type inference, we would have to specify the context \\(\\Gamma\\) beforehand and we need to define some general rules for type inference. These rules are:\n\\[\n\\begin{align*}\n\\text{Konst} & \\frac{}{\\Gamma \\vdash \\a : \\kappa} & \\text{if } \\Gamma, \\a : \\kappa \\\\\n\\text{Var} & \\frac{\\Gamma, \\, x : \\tau \\vdash t : \\sigma}{\\Gamma \\vdash \\lambda x : \\tau.t : \\tau \\to \\sigma} \\\\\n\\text{App} & \\frac{\\Gamma \\vdash t : \\sigma \\to \\tau \\quad \\Gamma \\vdash s : \\sigma}{\\Gamma \\vdash t \\, s : \\tau} \\\\\n\\text{Abs} & \\frac{\\Gamma, \\, x : \\tau \\vdash t : \\sigma}{\\Gamma \\vdash ( \\lambda x : \\tau.t ) : \\tau \\to \\sigma} \\\\\n\\end{align*}\n\\]\n\n\nType Inference Example\nA simple example of type inference would be the following:\nConsider the term \\(\\lambda x. x + 1\\). To determine its type under the context \\(\\Gamma\\), we use the rules of type inference as outlined above. Let’s break down the process step by step.\n\nVariable Rule (Var):\n\nThe term is an abstraction \\(\\lambda x.t\\) where \\(t = x + 1\\). We assume \\(x : \\N\\) as part of our context for the body \\(t\\) of the abstraction. This is because we are dealing with addition and the constant 1 is of type \\(\\N\\).\n\nApplication Rule (App):\n\nThe subterm \\(x + 1\\) is an application of the addition function to \\(x\\) and \\(1\\). In \\(\\Gamma\\), the addition function has the type \\(\\N \\to \\N \\to \\N\\). This means it takes two arguments of type \\(\\N\\) and returns a result of type \\(\\N\\). Since \\(x : \\N\\) and \\(1 : \\N\\), the term \\(x + 1\\) is well-typed and has the type \\(\\N\\).\n\nAbstraction Rule (Abs):\n\nWe now return to our original term \\(\\lambda x. x + 1\\). Since the body of the abstraction \\(x + 1\\) has type \\(\\N\\) and we assumed \\(x : \\N\\), the whole abstraction has the type \\(\\N \\to \\N\\). Therefore, the term \\(\\lambda x. x + 1\\) is well-typed under the context \\(\\Gamma\\) and has the type \\(\\N \\to \\N\\). This represents a function that takes a natural number as input and returns a natural number as output.\nThis results in the following derivation:"
  },
  {
    "objectID": "posts/surreal_numbers/index.html",
    "href": "posts/surreal_numbers/index.html",
    "title": "Surreale Zahlen",
    "section": "",
    "text": "In diesem Vortrag ging es darum zu zeigen, dass die surrealen Zahlen ein Körper sind. Ich arbeitete dabei unter der Annahme, dass wir bereits gezeigt haben, dass \\(\\boldsymbol{No}\\) ein geordneter Ring ist. Alles was somit noch zu zeigen war, war das multiplikative Inverse für beliebige nicht-nulle Elemente zu finden sind.\nGenaueres lässt sich in dem Handout nachlesen: Handout"
  },
  {
    "objectID": "posts/surreal_numbers/index.html#boldsymbolno-ist-ein-körper",
    "href": "posts/surreal_numbers/index.html#boldsymbolno-ist-ein-körper",
    "title": "Surreale Zahlen",
    "section": "",
    "text": "In diesem Vortrag ging es darum zu zeigen, dass die surrealen Zahlen ein Körper sind. Ich arbeitete dabei unter der Annahme, dass wir bereits gezeigt haben, dass \\(\\boldsymbol{No}\\) ein geordneter Ring ist. Alles was somit noch zu zeigen war, war das multiplikative Inverse für beliebige nicht-nulle Elemente zu finden sind.\nGenaueres lässt sich in dem Handout nachlesen: Handout"
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html",
    "href": "posts/new_method_of_counting_dimensions/index.html",
    "title": "A new method to calculate dimension",
    "section": "",
    "text": "A few days ago, I stumbled upon an article titled Finally We May Have a Path to the Fundamental Theory of Physics… and It’s Beautiful by Stephen Wolfram, an American scientist and the creator of WolframAlpha. His article discusses his new theory in physics, which is based on directed graphs and their transformations under specific rules. For more detailed information, here is the full version: www.wolframphysics.org/technical-introduction/.\nHis theory notably constructs mathematical spaces from these graphs, essentially nodes interconnected with each other."
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html#introduction-to-the-theory",
    "href": "posts/new_method_of_counting_dimensions/index.html#introduction-to-the-theory",
    "title": "A new method to calculate dimension",
    "section": "",
    "text": "A few days ago, I stumbled upon an article titled Finally We May Have a Path to the Fundamental Theory of Physics… and It’s Beautiful by Stephen Wolfram, an American scientist and the creator of WolframAlpha. His article discusses his new theory in physics, which is based on directed graphs and their transformations under specific rules. For more detailed information, here is the full version: www.wolframphysics.org/technical-introduction/.\nHis theory notably constructs mathematical spaces from these graphs, essentially nodes interconnected with each other."
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html#impact-on-dimensionality",
    "href": "posts/new_method_of_counting_dimensions/index.html#impact-on-dimensionality",
    "title": "A new method to calculate dimension",
    "section": "Impact on Dimensionality",
    "text": "Impact on Dimensionality\nThis raises the question of what this theory can reveal about the dimensionality of spaces. Much on this topic can be read in the article. In summary, using these graphs, the dimension of a space can be generalized. This generalization can then be extended to other mathematical objects, allowing for an expanded concept of dimension. This enables discussions about “2.5”-dimensional spaces or even “\\(\\pi\\)”-dimensional spaces. Importantly, we’re not limited to classical vector spaces made up of tuples (e.g., \\(\\mathbb{R}^3\\)); any set equipped with a metric can be used as our space.\nThe intriguing aspect here is that this new concept of dimension depends solely on a set and a metric defined on it, but a purely topological space doesn’t seem to suffice."
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html#my-initial-ideas",
    "href": "posts/new_method_of_counting_dimensions/index.html#my-initial-ideas",
    "title": "A new method to calculate dimension",
    "section": "My Initial Ideas",
    "text": "My Initial Ideas\nInitially, translating this concept to metric spaces was quite complex for me. However, in the end, the formulas were essentially the same. I made it unnecessarily complicated for myself by conducting my own research:\n\nMeine Ideen zum Dimensionsbegriff"
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html#how-does-this-concept-of-dimension-work",
    "href": "posts/new_method_of_counting_dimensions/index.html#how-does-this-concept-of-dimension-work",
    "title": "A new method to calculate dimension",
    "section": "How Does This Concept of Dimension Work?",
    "text": "How Does This Concept of Dimension Work?\nConsider the following graphs:\n\n\n\n\n2D Sphäre im Gitter\n\n\n\n\n\n3D Sphäre im Gitter\n\n\n\nBoth demonstrate how spheres spread in a lattice. According to Wolfram, this is formed by: “Start at some point in the hypergraph. Then follow \\(r\\) hyperedges in all possible ways. You’ve effectively made the analog of a ‘spherical ball’ in the hypergraph.”1\nFor any graph, one can choose a point and count how many points are reachable within \\(r\\) steps or fewer. If this spread resembles that of a polynomial, the degree can determine the dimension. However, determining the exact dimension is not trivial and is explained more thoroughly2 3 in Chapter 4.6 of the Wolfram Physics Project4."
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html#calculation-of-dimension",
    "href": "posts/new_method_of_counting_dimensions/index.html#calculation-of-dimension",
    "title": "A new method to calculate dimension",
    "section": "Calculation of Dimension",
    "text": "Calculation of Dimension\n\nNote\nThe following considers a version developed by me, which is inspired by the original.\n\n\nCalculation\nLet \\((M,d)\\) be a metric space.\n\\(M\\) is the set. \\(d: M\\times M \\rightarrow \\mathbb{R}_{\\ge 0}\\) is a metric. Let \\(V_{r,x} = |{y \\in M \\mid d(x,y) \\le r}|\\) be the number of points in a ball with radius \\(r\\).\nLet \\(\\Delta_{r,x} = \\frac{\\log(V_{r+1,x})-\\log(V_{r,x})}{\\log(r+1)-\\log(r)} = \\frac{\\log\\frac{V_{r+1,x}}{V_{r,x}}}{\\log{\\frac{r+1}{r}}}\\).\nNow, the following applies:\n\\[\n\\text{dim}(M,d) = \\begin{cases}\n\\lim_{r\\rightarrow \\infty}\\Delta_{r,x} & \\text{if}\\&gt; |M|\\ge\\infty \\wedge |V_{r,x}|&lt;\\infty\\\\\\\\\\\\\\\\\n\\lim_{r\\rightarrow \\infty}\\Delta_{r,x} & \\text{(?) if}\\&gt; |M|\\ge\\infty \\wedge |V_{r,x}|\\ge\\infty\\\\\\\\\\\\\\\\\n\\begin{gather}\nv\\in\\mathbb{R}_{\\ge 0} \\text{ with } \\\\\\\\\\\\\\\\\n|\\{\\Delta_{v\\pm\\epsilon,x}\\}| = \\max |\\{\\Delta_{w\\pm\\epsilon,x}\\}|\\\\\\\\\\\\\\\\\n\\forall \\epsilon,w\\in\\mathbb{R}_{\\ge 0}\n\\end{gather} & \\text{if}\\&gt; |M|&lt;\\infty\n\\end{cases}\n\\]\n\n\nExample 1\n\\[\n\\begin{aligned}\n    M      & = \\mathbb{Z}^2 \\\\\\\\\\\\\\\\\n    d(x,y) & = |x_1+y_1 + x_2+y_2| \\\\\\\\\\\\\\\\\n    V_{r,x}& = 2r^2+2r+1 \\quad\\forall x\\in M\\\\\\\\\\\\\\\\\n    \\Delta_{r,x} &= \\frac{\\log{\\left(2 r + 2 \\left(r + 1\\right)^{2} + 3 \\right)} - \\log{\\left(2 r^{2} + 2 r + 1 \\right)}}{- \\log{\\left(r \\right)} + \\log{\\left(r + 1 \\right)}} \\\\\\\\\\\\\\\\\n    \\lim_{r\\rightarrow\\infty}\\Delta_{r,x} &= 2\n\\end{aligned}\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nV = lambda r: 2*r**2+2*r+1\nDelta = lambda r: (np.log(V(r+1))-np.log(V(r)))/(np.log(r+1)-np.log(r))\nxn = np.arange(0.1, 100,1)\nfig, ax = plt.subplots()\nax.plot(xn, Delta(xn))\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExample 2\n\\[\n\\begin{aligned}\n    M      & = \\mathbb{Z}^2 \\\\\\\\\\\\\\\\\n    d(x,y) & = |x_1+y_1 + x_2+y_2| \\\\\\\\\\\\\\\\\n    V_{r,x}& = 2r^2+2r+1 \\quad\\forall x\\in M\\\\\\\\\\\\\\\\\n    \\Delta_{r,x} &= \\frac{\\log{\\left(2 r + 2 \\left(r + 1\\right)^{2} + 3 \\right)} - \\log{\\left(2 r^{2} + 2 r + 1 \\right)}}{- \\log{\\left(r \\right)} + \\log{\\left(r + 1 \\right)}} \\\\\\\\\\\\\\\\\n    \\lim_{r\\rightarrow\\infty}\\Delta_{r,x} &= 2\n\\end{aligned}\n\\]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nV = lambda r: 2*r**2+2*r+1\nDelta = lambda r: (np.log(V(r+1))-np.log(V(r)))/(np.log(r+1)-np.log(r))\nxn = np.arange(0.1, 100,1)\nfig, ax = plt.subplots()\nax.plot(xn, Delta(xn))\nax.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\nExample 3\nThe Sierpiński-Triangle is a fractal with a dimension of \\(\\log(3)/\\log(2)\\). The following code calculates the dimension of the Sierpiński-Triangle.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nsirp = lambda x: [[],[],[]] if x==[] else [ sirp(v) for v in x]\nrepeat = lambda f,x,n: f(x) if n==1 else f(repeat(f,x,n-1))\npoints = []\nstart  = np.array([1,1])\nangle  = 2*np.pi/3       # Winkel zwischen Punkten\nlength = 1               # Anfangslänge eines Punktes zum nächsten\ndecay  = 0.5             # Koeffizient, mit dem bei jeder Iterationstiefe die Länge zwischen Punkten sinkt\ndef calc(data, current_point=start, length=length):\n    if len(data)==0:\n        points.append(current_point)\n    for i in range(len(data)):\n        newpoint = current_point+np.array([\n            length * np.cos(angle * i),\n            length * np.sin(angle * i),\n        ])\n        calc(data[i], newpoint, length*decay)\n\n# Sierpiński Dreieck mit Rekursionstiefe rt\nrt = 6\ndata = repeat(sirp, [], rt)\ncalc(data)\n\n# Zeichnen\nx, y = np.array(points).T\nfig, ax = plt.subplots()\nax.scatter(x, y, s=1)\nplt.legend(['Ein Sierpiński Dreieck mit Rekursionstiefe $'+str(rt)+'$'])\nplt.show()\n\n\n\n\n\n\n\n\n\nrn = np.arange(0.1,2,0.025)\nd = np.hypot\nU = lambda r,p: [ q for q in points if d(*(p-q))&lt;=r ]\nV = lambda r,p: len(U(r,p))\ndef avg(r):\n    \"\"\"berechne die durchschnittliche Anzahl an Punkten in einer r großen Umgebung\n    \"\"\"\n    total = 0\n    for p in points:\n        total += V(r,p)\n    total /= len(points)\n    return total\n\nval = [avg(r) for r in rn]\nfig, ax = plt.subplots()\nax.plot(rn, val)\nplt.xlabel('Radius $r$')\nplt.legend(['Durchschnittliche Anzahl an Punkten in $V_r$'])\nplt.show()\n\n\n\n\n\n\n\n\n\ndn = [rn[i] for i in range(1,len(rn)-1)]\nDelta = lambda i: (np.log(val[i+1])-np.log(val[i]))/(np.log(rn[i+1])-np.log(rn[i]))\ndval = [Delta(i) for i in range(len(dn))]\n\nfig, ax = plt.subplots()\nax.plot(dn, dval)\nax.plot(dn, [np.log2(3) for _ in dn], '.:')\nplt.xlabel('Radius $r$')\nplt.ylabel('$\\Delta_r$')\nplt.legend(['Durchschnittliches $\\Delta_r$', 'Hausdorff Dimension von Sierpiński-Dreieck$\\approx\\log_2(3)$'])\n\n&lt;matplotlib.legend.Legend at 0x7fff2dddc650&gt;\n\n\nError in callback &lt;function _draw_all_if_interactive at 0x7fffcf4d8180&gt; (for post_execute), with arguments args (),kwargs {}:\n\n\nValueError: \nHausdorff Dimension von Sierpiński-Dreieck$\u0007pprox\\log_2(3)$\n                                          ^\nParseException: Expected end of text, found '$'  (at char 42), (line:1, col:43)\n\n\nValueError: \nHausdorff Dimension von Sierpiński-Dreieck$\u0007pprox\\log_2(3)$\n                                          ^\nParseException: Expected end of text, found '$'  (at char 42), (line:1, col:43)\n\n\n&lt;Figure size 672x480 with 1 Axes&gt;"
  },
  {
    "objectID": "posts/new_method_of_counting_dimensions/index.html#footnotes",
    "href": "posts/new_method_of_counting_dimensions/index.html#footnotes",
    "title": "A new method to calculate dimension",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#23_out↩︎\nhttps://www.wolframphysics.org/technical-introduction/limiting-behavior-and-emergent-geometry/the-notion-of-dimension/↩︎\nhttps://www.wolframphysics.org/technical-introduction/limiting-behavior-and-emergent-geometry/dimension-related-characterizations/↩︎\nhttps://www.wolframphysics.org/↩︎"
  },
  {
    "objectID": "posts/intersect.js/index.html",
    "href": "posts/intersect.js/index.html",
    "title": "intersect.mjs und der Sphären/Boxen-Schnitt",
    "section": "",
    "text": "Problem\nMomentan arbeite ich an meiner intersect.mjs Bibliothek, welche dafür da ist Kollisionen und Schnitte von verschiedenen geometrischen Strukturen in \\(n\\) dimensionen zu erkennen. Dabei ist gerade diese folgende Zeile zu einer Herausvorderung geworden:\n// plane2circle :: Real a =&gt; [(a,a)] -&gt; a -&gt; [a] -&gt; ([a] -&gt; Real) -&gt; Boolean\nconst plane2circle = (p,r,c,d=Math.hypot) =&gt;\n    //TODO\n\n\n\nAbkürzung\nName\nEigenschaft\nBeschreibung\n\n\n\n\np\nHyperwürfel\n[(a,a)]\nZwei Punkte im \\(\\mathbb{R}^n\\)\n\n\nr\nRadius\na\nRadius der Sphäre\n\n\nc\nPosition der Sphäre\n[a]\nPosition des Zentrums der Sphäre\n\n\nd\nMaß\n[a] -&gt; a\nEin verwendetes Maß aus der Maßtheorie\n\n\n\nhierbei verwende ich Haskell Schreibkonventionen für die Eigenschaften. Also, a bedeuted, ein beliebiger Datentyp oder [a,a] deuted auf zwei beliebige Daten (die nicht gleich sein müssen, des selben Types hin. Da ich Real a =&gt;... am Anfang geschrieben habe, bedeuted dass: [(a,a)] ist eine Liste von Tupeln verschiedener reeller Zahlen: \\(((a_{0_0},a_{0_1}),(a_{1_0},a_{1_1}),\\dots), \\quad a_{i_j} \\in \\mathbb{R}\\)\n\n\nLösung\nDamit ich diese Funktion dazu bringen konnte, zu funktionieren ist mir eine Lösung gekommen. Gegeben hatte ich bereits eine Funktion, welche prüft ob eine Hypersphäre und ein Punkt sich schneiden. Daher habe ich eine weitere Funktion geschrieben, welche prüft, ob sich ein Kreis und ein Intervall schneiden:\n// point2circle :: Num a =&gt; [a] -&gt; Real -&gt; [a] -&gt; ([a] -&gt; Real) -&gt; Boolean\nexport const point2circle = (p,r,q=p.map(_=&gt;0),d=Math.hypot) =&gt;\n    d(...p.map((x,i) =&gt; x-q[i])) &lt;= r;\n\n// interval2circle :: Num a =&gt; a -&gt; Real -&gt; [a,a] -&gt; Boolean\nexport const interval2circle = (c,r,i,d=Math.hypot) =&gt;\n    point2circle([c], r+Math.abs(i[0]-i[1])/2, [(i[0]+i[1])/2], d)\nNun ist es ein Leiches, zu prüfen ob ein Hyperwürfel und eine Hypersphäre sich schneiden; Man muss prüfen ob die Projektionen der Sphäre und des Hyperwürfels sich auf jeder Achse schneiden.\n\n\n\n\n// plane2circle :: Num a =&gt; [(a,a)] -&gt; Real -&gt; [a] -&gt; ([a] -&gt; Real) -&gt; Boolean\nexport const plane2circle = (p,r,c,d=Math.hypot) =&gt; p\n    .map((i,j) =&gt; interval2circle(c[j],r,i,d) )\n    .every(e =&gt; e==true)\nund diese Funktion können wir nun testen:\nimport * as int from './intersect.mjs'\n\nlet p = [[0,1],[0,1],[0,1]]\nlet r = 1\nlet c = [0,0,0]\nconsole.log(int.plane2circle(p,r,c)) // true ✅\n\nlet p = [[0,1],[0,1],[0,1]]\nlet r = 1\nlet c = [0,0,2]\nconsole.log(int.plane2circle(p,r,c)) // false ✅\n\nlet p = [[0,1],[0,1]]\nlet r = 1\nlet c = [2,2]\nconsole.log(int.plane2circle(p,r,c)) // false ✅\nbesonders das letzte Ergebnis kann man leicht überprüfen:\n\n\n\ngeometrischer Beweis\n\n\n\n\nFazit\nDas Problem Schnitte zwischen höherdimensinalen Sphären und Würfeln zu lösen war nicht all zu einfach auf den ersten Blick; doch verwendet man (wortwörtlich) verschiedene Perspektiven und ist bereit bereits bekannte Resultate (wie point2circle) zu verwenden und neue zu finden (wie interval2circle), so ist es doch ein Leichtes gewesen eine allgemeine Lösung zu finden."
  },
  {
    "objectID": "posts/first_program_in_AUR/index.html",
    "href": "posts/first_program_in_AUR/index.html",
    "title": "My first program in the AUR",
    "section": "",
    "text": "Recently I discovered some more of the incredibly useful features of my favorite text-editor Neovim:\n\nEntering :read !somefunction in Neovim causes the editor to execute the command somefunction and then insert the echoed response into the file you are currently editing at your cursor position.\n\nThis got me thinking… Maybe I could use this to make my programming more concise. And after installing figlet I was proven right:\n# Use `:read figlet \"Example\"`\n#     and then select the output and comment it out: `:'&lt;,'&gt;norm ^i# `\n#\n#  _____                           _\n# | ____|_  ____ _ _ __ ___  _ __ | | ___\n# |  _| \\ \\/ / _` | '_ ` _ \\| '_ \\| |/ _ \\\n# | |___ &gt;  &lt; (_| | | | | | | |_) | |  __/\n# |_____/_/\\_\\__,_|_| |_| |_| .__/|_|\\___|\n#                           |_|\necho \"It works!\"\nAnd after all this thinking I was stuck with an idea, which I had for quite some time already, but never really knew how to implement in vim:\nI can use this, to show complex math formulas in programs, as actual math formulas {: text-align: center}\nThe problem however was, that no package I searched for seemed to provide the ability to render math formulas as ASCII / ANSI / Unicode. And therefor I just set out to create my own program:\n\nprettymath\nThe programming was the easy part. Just write a python script that internally parses expressions using SymPy and then pretty prints them. But publishing this program with none more than ~50 lines of code was a real pain.\n\nPublish to GitHub\nCreate an account on https://aur.archlinux.org\nUse my .ssh/config\nGenerate an ssh key: $ ssh-keygen -f ~/.ssh/aur\nClone your future repository: git clone ssh://aur@aur.archlinux.org/your_package_name.git\nPut your PKGBUILD in there\nAdd, Commit, Push\n\n\nSSH Configuration\n$ cat .ssh/config\nHost aur.archlinux.org\nUser aur\nPreferredAuthentications publickey\nIdentityFile ~/.ssh/aur\n\nAnd after all this struggle, which even drove me to reddit because I had no clue anymore on what to do, I was able to install my package using the AUR:\nyay -S prettymath-git\n\n\n\nWhat does it do?\nAfter having installed prettymath-git, you can do stuff like this:\nbefore prettymath\nimport math\n\ndef normalDistribution(x):\n    return 1/sqrt(math.pi)*math.e**(-x**2)\nafter prettymath (:read !prettymath -u \"1/sqrt(pi) * e**(-x**2)\"; :norm ^i#)\nimport math\n\ndef normalDistribution(x):\n    #    2\n    #  -x\n    # e\n    # ────\n    #  √π\n    return 1/sqrt(math.pi)*math.e**(-x**2)"
  },
  {
    "objectID": "posts/differential_forms/index.html",
    "href": "posts/differential_forms/index.html",
    "title": "What are „differential forms“",
    "section": "",
    "text": "Currently while visiting the “KoMa” (Konferenz der deutschsprachigen Mathematikfachschaften / conference of German-speaking mathematics students) I got into a lot of interesting conversations about geometry, topology and category theory. This set the stage for me to think about differential forms because I wanted to understand how exactly these things look and feel like."
  },
  {
    "objectID": "posts/differential_forms/index.html#introduction",
    "href": "posts/differential_forms/index.html#introduction",
    "title": "What are „differential forms“",
    "section": "",
    "text": "Currently while visiting the “KoMa” (Konferenz der deutschsprachigen Mathematikfachschaften / conference of German-speaking mathematics students) I got into a lot of interesting conversations about geometry, topology and category theory. This set the stage for me to think about differential forms because I wanted to understand how exactly these things look and feel like."
  },
  {
    "objectID": "posts/differential_forms/index.html#my-sketches",
    "href": "posts/differential_forms/index.html#my-sketches",
    "title": "What are „differential forms“",
    "section": "My sketches",
    "text": "My sketches\n\nNotes about differential forms\n\n\nThe proof mentioned on page 1 is viewable on https://web.archive.org/web/20211224033113/https://planetmath.org/tensorproductofdualspacesisadualspaceoftensorproduct"
  },
  {
    "objectID": "posts/differential_forms/index.html#notation",
    "href": "posts/differential_forms/index.html#notation",
    "title": "What are „differential forms“",
    "section": "Notation",
    "text": "Notation\nThroughout this article we will choose the following symbols and notation:\n\n\\(M\\) a smooth manifold over a field \\(K\\subset \\mathbb{R}\\)\n\\(p\\in M\\) a point in \\(M\\)\n\\(T_p M\\) the tangent space of \\(M\\) at \\(p\\)\n\\(T_p^\\ast M\\) the cotangent space of \\(M\\) at \\(p\\), which consists of the linear functions \\(\\phi: T_p M \\to K\\). For finite tangent spaces \\(T_p M\\), we can canonically identify \\(T_p^\\ast M\\) with \\(T_p M\\).\n\\(T M = \\bigcup_{p\\in M} \\{p\\}\\times T_p M\\) and \\(T^\\ast M = \\bigcup_{p\\in M} \\{p\\}\\times T_p^\\ast M\\) are the tangent/cotangent bundles of \\(M\\)\n\\(\\Lambda^k(T^\\ast M)\\) is the k-th exterior product of the cotangent bundle of \\(M\\). Its elements \\(\\mu_p\\in\\Lambda^k(T^\\ast M)\\) are called k-coblades and allow to measure volumes on some tangent space \\(T_pM\\) in \\(k\\)-dimensions.\n\\(\\Gamma(M, \\Lambda^k(T^\\ast M)) = \\Gamma(\\Lambda^k(T^\\ast M))\\) is the space of global sections from the basespace \\(M\\) to the total space \\(\\Lambda^k(T^\\ast M)\\). We use this, because for an element \\(\\omega:M \\to \\Lambda^k(T^\\ast M)\\) in it, we can smoothly associate for each point \\(p\\) on \\(M\\) a k-coblade."
  },
  {
    "objectID": "posts/differential_forms/index.html#formal-definition",
    "href": "posts/differential_forms/index.html#formal-definition",
    "title": "What are „differential forms“",
    "section": "Formal definition",
    "text": "Formal definition\nA differential form \\(\\omega\\) is defined as an element in the space of global sections over the kth exterior algebra of the cotangent bundle over a smooth manifold \\(M\\). We denote this as:\n\\[\\omega \\in \\Gamma(M, \\Lambda^k(T^\\ast M))\\]"
  },
  {
    "objectID": "posts/differential_forms/index.html#my-interpretation",
    "href": "posts/differential_forms/index.html#my-interpretation",
    "title": "What are „differential forms“",
    "section": "My interpretation",
    "text": "My interpretation\nBasically, a differential 1-form can be visualized as appending a vector onto each point of our manifold. Because we work with a smooth section, these vectors need to vary “smoothly” from one point to another. This means, if we wiggle the point we look at on our manifold just a tiny bit, the vector we have related to this point will also wiggle just a tiny bit. Also, our corresponding vector cannot take any sharp turns if we do not move our point in sharp turns."
  },
  {
    "objectID": "posts/bildbesucher-jsdoc/index.html",
    "href": "posts/bildbesucher-jsdoc/index.html",
    "title": "Bildbesucher - First time using JSDoc",
    "section": "",
    "text": "As you can see in the image above, today I’ve added JSDoc support to my game, BildBesucher. This means that by visiting http://quoteme.github.io/bildbesucher/docs/, you can find all sorts of interesting information about the programming of the game. This will make it easier for me in the future to remember the purpose of specific functions, or for others who want to help with the project to quickly understand what I’ve written.\nUnfortunately, this required me to almost double the number of lines of code, but these changes are just comments, so they don’t slow down the program!\nThe goal of this whole exercise is to improve my programming style and enhance my teamwork skills, as I’ve learned how to annotate my work effectively.\nThis could also be useful in other areas, as it reminds me of the importance of keeping good records for colleagues. I’ve learned that it’s important to keep a good record of what I’ve done, so that others can understand it and help me improve it. This is often overlooked even in professional settings, but documentation is a key part of any project.\n\nOverview of my first jsdoc documentation ({{site.url}}/bildbesucher/docs)"
  },
  {
    "objectID": "posts/algebra_meme_2/index.html",
    "href": "posts/algebra_meme_2/index.html",
    "title": "Prove that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - A proof",
    "section": "",
    "text": "Around one year ago I tried to solve the following riddle involving abstract algebra, but I failed and did not finish the question at that\n\n\n\nProve that Rx/(x^2+bx+c) is isomorphic to R^2 or C"
  },
  {
    "objectID": "posts/algebra_meme_2/index.html#the-exercise",
    "href": "posts/algebra_meme_2/index.html#the-exercise",
    "title": "Prove that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - A proof",
    "section": "",
    "text": "Around one year ago I tried to solve the following riddle involving abstract algebra, but I failed and did not finish the question at that\n\n\n\nProve that Rx/(x^2+bx+c) is isomorphic to R^2 or C"
  },
  {
    "objectID": "posts/algebra_meme_2/index.html#the-proof",
    "href": "posts/algebra_meme_2/index.html#the-proof",
    "title": "Prove that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - A proof",
    "section": "The proof",
    "text": "The proof\nLet \\(f=x^2+bx+c\\in\\mathbb{R}[x]\\). \\(f\\) can either have one double root, iff the discriminant \\(\\Delta f=b^2-4c\\) is zero, or it can have two real roots iff \\(\\Delta f&gt;0\\), or it can have two complex roots iff \\(\\Delta f&lt;0\\).\n\nNegative discriminant\nIf \\(\\Delta f&gt;0\\) we have \\(f(x)\\in\\mathbb{R}\\) with \\(x\\not\\in\\mathbb{R}\\). We can rewrite \\(f(x)=x^2+bx+c=0\\) to be \\(x^2+bx=-c\\), and therefor \\(x^2+bx\\in\\mathbb{R}\\). Also, because \\(\\Delta f&gt;0\\), we know that that we can split \\(f(x)\\) into its linear factors \\(f(x)=(x-w)(x-v)\\) with \\(w,v\\in\\mathbb{R}\\). This means that our number \\(x\\) will be equal to \\(0\\) if we subtract a real number from it, meaning it must be real, thereofr concluding that \\(\\mathbb{R}/(x^2+bx+c)\\cong \\mathbb{R}\\times \\mathbb{R}\\)\n\n\nPositive discriminant\nIn case our discriminant \\(\\Delta f\\) is positive we know that \\(f(x)\\) cannot be split into real linear monomial factors, which means that \\(x\\) cannot be a real number. Also, because \\(f\\) only has purely complex roots, \\(x\\) must be a purely complex number as well. Because \\(\\mathbb{R}[x]/(f)\\) is a vectorspace over \\(\\mathbb{R}\\) we know that \\(\\alpha x+\\beta=i\\) for \\(\\alpha, \\beta\\in \\mathbb{R}\\), concluding that \\(\\mathbb{R}[x]/(x^2+bx+c) \\cong \\mathbb{R}[i]=\\mathbb{C}\\)"
  },
  {
    "objectID": "posts/algebra_meme_2/index.html#conclusion",
    "href": "posts/algebra_meme_2/index.html#conclusion",
    "title": "Prove that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - A proof",
    "section": "Conclusion",
    "text": "Conclusion\nReading Bosch Algebra really helped me grasp some of the concepts like field extensions some more. I assume that this knowledge also took some time to ripen inside my brain, but after some time algebra finally makes more sense to me. Also I finished my exam about abstract algebra a few months ago! (While also studying for commutative algebra and already having finished my introductory course in algebraic geometry)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "{{< var website.title >}}",
    "section": "",
    "text": "Hi, I am Luca Leon Happel. I am a Software Engineer and B.Sc in mathematics (algebraic geometry), who works at the Heinrich Heine University, Forschungszentrum Jülich and Universitätsklinikum Düsseldorf.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModeltheory 1\n\n\n\n\n\n\nmathematics\n\n\nlogic\n\n\nmodeltheory\n\n\n\n\n\n\n\n\n\nMar 2, 2024\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nAutomated theorem proving\n\n\n\n\n\n\nmathematics\n\n\nlogic\n\n\nautomated theorem proving\n\n\nlean4\n\n\nformal verification\n\n\n\n\n\n\n\n\n\nFeb 21, 2024\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\ell^2\\)-Invariants\n\n\n\n\n\n\nmathematics\n\n\ntopology\n\n\nalgebra\n\n\ngroup theory\n\n\nring theory\n\n\nmeasure theory\n\n\nfunctional analysis\n\n\ndifferential geometry\n\n\ndifferential topology\n\n\nalgebraic topology\n\n\n\nThis article is about the \\(\\ell^2\\)-Invariants of \\(G\\)-CW-complexes. We will start by constructing the \\(\\ell^2\\)-completion of cellular chain complexes and then take a look at some applications of the \\(\\ell^2\\)-completion of cellular chain complexes. We will calculate the \\(\\ell^2\\)-homology groups and the \\(\\ell^2\\)-betti numbers of \\(S^\\infty := \\colim_n S^n\\) with the group \\(G:=\\prod_{n=0}^\\infty \\Z/2\\Z\\) acting on it. We will also take a look at the \\(\\ell^2\\)-betti numbers of the torus and the \\(\\ell^2\\)-betti numbers of the universal covering space of the torus. Finally, we will take a look at Lück’s theorem and its implications for the \\(\\ell^2\\)-betti numbers of the universal covering space of a connected, compact CW-complex whose fundamental group is residually finite. \n\n\n\n\n\nFeb 4, 2024\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nSurreale Zahlen\n\n\n\n\n\n\nSeminar\n\n\nSurreale Zahlen\n\n\nabstract algebra\n\n\nring theory\n\n\n\n\n\n\n\n\n\nNov 16, 2023\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nHaskell - Angewandter „abstract nonsense“\n\n\n\n\n\n\nSeminar\n\n\nHaskell\n\n\nprogramming\n\n\nHeinrich-Heine Universität\n\n\n\n\n\n\n\n\n\nJan 23, 2023\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nWhat are „differential forms“\n\n\n\n\n\n\nmathematics\n\n\ndifferential geometry\n\n\ndifferential forms\n\n\ntangent space\n\n\ncotangent space\n\n\nmanifold\n\n\ntangent bundle\n\n\ncotangent bundle\n\n\nexterior algebra\n\n\nglobal section\n\n\n\n\n\n\n\n\n\nMay 27, 2022\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nElliptic curves over the field with four elements (not finished)\n\n\n\n\n\n\nmathematics\n\n\nalgebraic geometry\n\n\n\n\n\n\n\n\n\nMar 1, 2022\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nSheaves in Minecraft\n\n\n\n\n\n\nmath\n\n\nalgebraic geometry\n\n\nsheaves\n\n\ntopology\n\n\nMinecraft\n\n\n\n\n\n\n\n\n\nOct 29, 2021\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nProve that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - A proof\n\n\n\n\n\n\nmath\n\n\nalgebra\n\n\nabstract algebra\n\n\nring theory\n\n\nmeme\n\n\n\n\n\n\n\n\n\nOct 21, 2021\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nProve that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - First try\n\n\n\n\n\n\nmath\n\n\nalgebra\n\n\nring theory\n\n\nabstract algebra\n\n\npolynomial rings\n\n\nquotient rings\n\n\nisomorphisms\n\n\n\n\n\n\n\n\n\nDec 3, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nA new method to calculate dimension\n\n\n\n\n\n\nmath\n\n\nfractals\n\n\ndimension\n\n\ncalculus\n\n\ngeometry\n\n\n\n\n\n\n\n\n\nMay 22, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nBildbesucher - First time using JSDoc\n\n\n\n\n\n\nJSDoc\n\n\nJavaScript\n\n\ngame\n\n\nprogramming\n\n\n\n\n\n\n\n\n\nApr 18, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nBildbesucher - A simple jump and run game\n\n\n\n\n\n\nprogramming\n\n\ngame\n\n\nart\n\n\njavascript\n\n\nhtml\n\n\ncss\n\n\n\n\n\n\n\n\n\nApr 7, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nMy first program in the AUR\n\n\n\n\n\n\nprogramming\n\n\naur\n\n\narchlinux\n\n\n\n\n\n\n\n\n\nMar 28, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nGlider - A simple boids based video game\n\n\n\n\n\n\njavascript\n\n\ngame\n\n\nboids\n\n\n\n\n\n\n\n\n\nFeb 27, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\n\n\n\n\n\n\nintersect.mjs und der Sphären/Boxen-Schnitt\n\n\n\n\n\n\njavascript\n\n\nprogramming\n\n\nwebgl\n\n\nmath\n\n\n\n\n\n\n\n\n\nFeb 14, 2020\n\n\nLuca Leon Happel\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I am Luca Leon Happel, a 24-year-old Student in Düsseldorf and a top-100 on GitHub in categories like physics-engines and rigid-body-dynamics. My interests include mathematics, computer science, technology and lots more. I work as a programmer for monti.ai and as a student assistant at the Heinrich Heine University Düsseldorf."
  },
  {
    "objectID": "about.html#education",
    "href": "about.html#education",
    "title": "About",
    "section": "Education",
    "text": "Education\n\n\n\n\n\n\n\n\nAchievement\nPlace\nDuration\n\n\n\n\nElementary school\nErich-Kästner Grundschule\n2006-2010\n\n\nGymnasium\nGymnasium an der Gartenstraße\n2010-2018\n\n\nBachelor of Mathematics\nHHU Düsseldorf\n2018-2022\n\n\nBachelor of Computer-Science\nHHU Düsseldorf\n2018-*"
  },
  {
    "objectID": "about.html#conferences",
    "href": "about.html#conferences",
    "title": "About",
    "section": "Conferences",
    "text": "Conferences\n\nKoMa (conference of german speaking mathematics student associations) 2022 in Jena\n\nWe discussed general mathematics, studying mathematics at german universities and the future of mathematics\nI discussed differential forms especially\n\nLean for the Curious Mathematician 2023 in Düsseldorf\n\nWe discussed Lean, a theorem prover and functional programming language\nI implemented the code for exterior algebras in Lean with a small team of professors and Eric Wieser"
  },
  {
    "objectID": "about.html#work-experience",
    "href": "about.html#work-experience",
    "title": "About",
    "section": "Work experience",
    "text": "Work experience\n\n\n\nExperience\nEmployer\nDuration\n\n\n\n\n2-week work internship\nProVita\n2017\n\n\nLifeguard\nNEW Volksbad Mönchengl.\n2018\n\n\nResearch assistant for computer-aided linear algebra\nHeinrich Heine University Düsseldorf\n2020-2021\n\n\nResearch assistant for computer-aided linear algebra\nHeinrich Heine University Düsseldorf\n2021-2022\n\n\nSHK for abstract algebra\nHeinrich Heine University Düsseldorf\n2022-2022\n\n\nProgrammer and founder at monti.ai\nmonti.ai\n2022-*"
  },
  {
    "objectID": "about.html#awards",
    "href": "about.html#awards",
    "title": "About",
    "section": "Awards",
    "text": "Awards\n\n\n\nAward\nSource\nDate\n\n\n\n\nWinner of “best game under development” with “Relic Hunters Zero”\nBrazilian indie games festivals 2015\n2015\n\n\nTop-100 physics-engine programmer\nxscode.com archive.org\n2021\n\n\nTop-100 rigid-body-dynamics programmer\nxscode.com archive.org\n2021\n\n\nTop-1000 canvas-technology developer\nxscode.com archive.org\n2021\n\n\nTop-150.000 programmer\nxscode.com archive.org\n2021"
  },
  {
    "objectID": "about.html#some-other-skills",
    "href": "about.html#some-other-skills",
    "title": "About",
    "section": "Some other skills",
    "text": "Some other skills\n\n\nclick to expand\n\n\n“Advanced” knowledge of mathematics\n\naiming for a Master degree in mathematics\n\nProgramming knowledge\n\nTop 50 programmer in physics-engines and rigid-body-dynamics as well as top 1000 canvas-technology, and top 150,000 GitHub developer (Source: www.xscode.com/profile/quoteme)\nactively programming since age 13 (2012)\na lot of experience in (&gt;50 Projects): - JavaScript\n\nNodeJS\nCSS\nHTML\nMarkdown\n\nadvanced experience in (&gt;10 Projects): - Haskell - Python (multiple courses in university)\nstudied in university/school: - Python\n\nJAVA\nC\nAssembler\nPHP\nSQL\nUML diagrams\n\nextraordinary experiences’\n\ncodeveloper of relic hunters zero\n\n95% positive reviews from 6,444 (2020)\nwinner of the “best game under development Brazilian indie games festivals 2015”\nhonorable mention in “battle of games VI festival Cindemundo 2014”\n\n\n\nSocial expertise\n\nvery social, patient and reliable\nresilient in stressful situations\nchildren tend to like me\nalways open to new cultures, experiences, people,…\n\nLanguages - native in German - fluent in English - basic understanding of Turkish"
  },
  {
    "objectID": "posts/algebra_meme/index.html",
    "href": "posts/algebra_meme/index.html",
    "title": "Prove that \\(\\mathbb{R}[x]/(x^2+bx+c)\\) is isomorphic to \\(\\mathbb{R}^2\\) or \\(\\mathbb{C}\\) - First try",
    "section": "",
    "text": "A few minutes ago I stumbled upon this meme on some math and science forum:\n\n\n\nProve that Rx/(x^2+bx+c) is isomorphic to R^2 or C\n\n\nHere is my thought process:\n\\(b^2-4c\\) is just the discriminant of the polynomial \\(f(x) = x^2+bx+c\\), and I will refer to it from now on as \\(\\Delta(f)\\).\nWe know that if \\(\\Delta(f)&gt;0\\) then the formula \\(\\frac{-b\\pm\\sqrt{b^2-4c}}{2} = -\\frac{b}{2} \\pm \\sqrt{\\left(\\frac{b}{2}\\right)^2 - c}\\) gives us the zeros \\(x_1, x_2 \\in \\mathbb{R}\\) of \\(f\\). Let’s look at \\(\\mathbb{R}[x] / (f)\\). And identify each part now.\n\nThe principal ideal \\((f) \\overbrace{=}^{\\mathbb{R}[x] \\text{ commutative}} \\{ p(x)\\cdot \\underbrace{f(x)}_{x^2+bx+c \\\\ = (x-x_1)(x-x_2) } \\mid p(x) \\in \\mathbb{R}[x]\\}\\)\nThe quotient ring \\(\\mathbb{R} [x]/(f)\\), which is the same as \\(\\mathbb{R}[x]/\\sim\\) where \\(\\sim\\) is an equivalence relation: \\(a\\sim b \\Leftrightarrow a-b \\in (f)\\)\nWhen performing polynomial division \\(\\frac{p(x)}{f(x)}, \\&gt; p(x)\\in\\mathbb{R}[x]\\) if \\(\\deg(p(x))&gt;2\\) we can always perform at least one step and the remainder must be of the form \\(ax+b \\in \\mathbb{R}[x]/(f)\\)\n\nThe solution to this problem can be found in this blog post"
  },
  {
    "objectID": "posts/bachelor-seminar-haskell/index.html",
    "href": "posts/bachelor-seminar-haskell/index.html",
    "title": "Haskell - Angewandter „abstract nonsense“",
    "section": "",
    "text": "Dieses Semester habe ich einen Kurs in der Heinrich-Heine Universität in Düsseldorf belegt, welcher sich mit verschiedenen Programmiersprachen beschäftigte. Dabei habe ich einen Vortrag über Haskell gehalten, welche eine Sprache ist, die mir sehr am Herzen liegt. Zu dem Seminar gehörte es, einen Vortag über 45 Minuten zu halten, zusammen mit dem Design eines Übungsblattes, welches die erlernten Fähigkeiten in 30 Minuten testen sollte. Außerdem sollte eine Ausarbeitung, welche im Umfang einer Bachelorarbeit war, angefertigt werden und es sollten zwei Rezensionen zu den angefertigten Bachelorarbeiten anderer Studienrenden angefertigt werden.\nDas Resultat ist meiner Meinung nach bei mir sehr gut ausgefallen, weshalb ich es hier teile:\n\n\n\n\n\n\n\n\n\n\nBildschirmfoto von der Ausarbeitung\n\n\n\nAufgaben\nMusterlösungen"
  },
  {
    "objectID": "posts/bachelor-seminar-haskell/index.html#einleitung",
    "href": "posts/bachelor-seminar-haskell/index.html#einleitung",
    "title": "Haskell - Angewandter „abstract nonsense“",
    "section": "",
    "text": "Dieses Semester habe ich einen Kurs in der Heinrich-Heine Universität in Düsseldorf belegt, welcher sich mit verschiedenen Programmiersprachen beschäftigte. Dabei habe ich einen Vortrag über Haskell gehalten, welche eine Sprache ist, die mir sehr am Herzen liegt. Zu dem Seminar gehörte es, einen Vortag über 45 Minuten zu halten, zusammen mit dem Design eines Übungsblattes, welches die erlernten Fähigkeiten in 30 Minuten testen sollte. Außerdem sollte eine Ausarbeitung, welche im Umfang einer Bachelorarbeit war, angefertigt werden und es sollten zwei Rezensionen zu den angefertigten Bachelorarbeiten anderer Studienrenden angefertigt werden.\nDas Resultat ist meiner Meinung nach bei mir sehr gut ausgefallen, weshalb ich es hier teile:\n\n\n\n\n\n\n\n\n\n\nBildschirmfoto von der Ausarbeitung\n\n\n\nAufgaben\nMusterlösungen"
  },
  {
    "objectID": "posts/bildbesucher/index.html",
    "href": "posts/bildbesucher/index.html",
    "title": "Bildbesucher - A simple jump and run game",
    "section": "",
    "text": "Recently, I’ve started to develop a game again, finding a bit of a positive side during the current Corona crisis.\nI’ve named the game “BildBesucher,” which is centered around the idea of exploring online images with a small character, moving from one picture to the next. This concept was inspired by my experience playing XKCD’s “Hoverboard” (XKCD Hoverboard), which I greatly enjoyed. You can view and even fork the source code on the corresponding Github page.\nThere are quite a few plans for the game’s development. A key priority is to add a zoom function to the in-game camera soon, so players can discover more about the drawn world. Other important features I want to work on include:\n\nA portal system for navigating to different pages at specific points.\nA loading system to load specific levels via URL, with various properties like position and so on.\nExpanding the world further by creating more images and enhancing the existing ones.\n???\n\n\nBilder zu meinem Spiel: BildBesucher ({{site.url}}/bildbesucher/)\n\n\nPS: I hope to make more progress with my game this time around."
  },
  {
    "objectID": "posts/elliptic_curves_over_F4/index.html",
    "href": "posts/elliptic_curves_over_F4/index.html",
    "title": "Elliptic curves over the field with four elements (not finished)",
    "section": "",
    "text": "Table of contents\nIntroduction\nThe Field \\(\\mathbb{F}_4\\) with four elements\nThe affine plane\n\nExample of a reducible hypersurface\nExample of an irreducible hypersurface\nExample of an irreducible hypersurface that is an elliptic curve\n\nThe projective space"
  },
  {
    "objectID": "posts/elliptic_curves_over_F4/index.html#table-of-contents",
    "href": "posts/elliptic_curves_over_F4/index.html#table-of-contents",
    "title": "Elliptic curves over the field with four elements (not finished)",
    "section": "",
    "text": "Table of contents\nIntroduction\nThe Field \\(\\mathbb{F}_4\\) with four elements\nThe affine plane\n\nExample of a reducible hypersurface\nExample of an irreducible hypersurface\nExample of an irreducible hypersurface that is an elliptic curve\n\nThe projective space"
  },
  {
    "objectID": "posts/elliptic_curves_over_F4/index.html#introduction",
    "href": "posts/elliptic_curves_over_F4/index.html#introduction",
    "title": "Elliptic curves over the field with four elements (not finished)",
    "section": "Introduction",
    "text": "Introduction"
  },
  {
    "objectID": "posts/elliptic_curves_over_F4/index.html#the-field-mathbbf_4-with-four-elements",
    "href": "posts/elliptic_curves_over_F4/index.html#the-field-mathbbf_4-with-four-elements",
    "title": "Elliptic curves over the field with four elements (not finished)",
    "section": "The Field \\(\\mathbb{F}_4\\) with four elements",
    "text": "The Field \\(\\mathbb{F}_4\\) with four elements"
  },
  {
    "objectID": "posts/elliptic_curves_over_F4/index.html#the-affine-plane",
    "href": "posts/elliptic_curves_over_F4/index.html#the-affine-plane",
    "title": "Elliptic curves over the field with four elements (not finished)",
    "section": "The affine plane",
    "text": "The affine plane\nWe define the affine space \\(\\mathbb{A}^n_k\\) over a ground field \\(k\\) to be the set of all tuples \\((x_1, \\dots, x_n)\\) with elements in \\(k\\). In the case of \\(n=2\\) we call \\(\\mathbb{A}^n_k\\) affine plane. A variety \\(V(A)\\) for a subset \\(A\\subset k[X_1, \\dots, X_n]\\) of polynomials is the set points in \\(\\mathbb{A}^n_k\\) which are zeros for each polynomial in \\(A\\). We call \\(V(A)\\) a hypersurface, if \\(A=\\{f\\}\\) contains only one element.\nWe can define a topology on \\(\\mathbb{A}^n_k\\) by defining the open sets to be the sets \\(V(f)\\) for each \\(f\\in k[X_1,\\dots, X_n]\\). I will not go into detail as to why this results in a topology. As an example, we can always construct \\(V(f_1) \\cup\\dots\\cup V(f_r) = V(f_1\\cdot\\dots\\cdot f_r)\\)\n\nThis image shows how solution sets can be united by multiplying the underlying functions. We use the affine real line \\(\\mathbb{A}^1_\\mathbb{R}\\) for this illustration. The green function is the product of the blue and red one and as can be seen, the green graph has exactly the same poles as the red and blue graph combined. Furthermore, we define a hypersurface \\(V(f)\\) to be irreducible if the underlying polynomial \\(f\\) is irreducible. A hypersurface is reducible if it is not irreducible.\n\nExample of a reducible hypersurface\nConsider \\(f=(x-y)(x+y)\\) which is reducible in \\(\\mathbb{R}[x,y]\\) as it can be factored into the non-units: \\((x-y)\\) and \\((x+y)\\).\nThis can be seen in the graph of \\(V(f)\\), because \\(V(f)\\) can be split into two hypersurfaces \\(V(x-y)\\) and \\(V(x+y)\\).\n\n\n\nExample of an irreducible hypersurface\nConsider \\(f=x^2+y^2-1\\). This defines the circle \\(V(f) = S^1\\).\n\n\n\nExample of an irreducible hypersurface that is an elliptic curve\nAnother irreducible hypersurface is \\(V(y^2-x^3+x)\\) in \\(\\mathbb{A}^2_\\mathbb{R}\\).\n\nThis also happens to define an elliptic curve. Also, note that an irreducible hypersurface need not be a connected space in the sense of topology."
  },
  {
    "objectID": "posts/elliptic_curves_over_F4/index.html#the-projective-space",
    "href": "posts/elliptic_curves_over_F4/index.html#the-projective-space",
    "title": "Elliptic curves over the field with four elements (not finished)",
    "section": "The projective space",
    "text": "The projective space"
  },
  {
    "objectID": "posts/glider/index.html",
    "href": "posts/glider/index.html",
    "title": "Glider - A simple boids based video game",
    "section": "",
    "text": "Today, while revisiting my old laptop, I rediscovered a project from just over a year and a month ago:\n\n\n\nScreenshot of the game\n\n\nNamed Glider, this project can be experienced and played directly in a web browser, without any need for installation, at http://quoteme.github.io/glider/.\nThe core intention of Glider was to serve as a proof-of-concept, demonstrating my capability to recreate a game akin to LUFTRAUSERS. Although my version, the “clone”, offers a limited range of functions, it successfully fulfills the objective I set out to achieve.\nKey features include:\nA retro aesthetic Sophisticated enemy AI The option to choose from varying team numbers The facility to take control of any other glider in the game."
  },
  {
    "objectID": "posts/l2-invariants/index.html",
    "href": "posts/l2-invariants/index.html",
    "title": "\\(\\ell^2\\)-Invariants",
    "section": "",
    "text": "This semester (WiSe 2023/24) I took a course about \\(\\ell^2\\)-Invariants(see Jun.-Prof. Dr. H. Kammeyer 2024) at the University of Düsseldorf. As a reminder, \\(\\ell^2\\) is the Hibert space of square-summable sequences of complex numbers. Meaning, a sequence \\((a_n\\in\\C)_{n=0}^\\infty\\) is in \\(\\ell^2\\) if and only if \\(\\sum_{n=0}^\\infty |a_n|^2 &lt; \\infty\\). By defining an inner product on \\(\\ell^2\\) as \\(\\langle a, b \\rangle = \\sum_{n=0}^\\infty a_n \\overline{b_n}\\), we make \\(\\ell^2\\) to a complete complex inner product space, i.e. a Hilbert space.\nFor context, this course was part of my master’s degree in mathematics and it was the culmination of a series of courses about Algebraic Topology, which I attended for the past two and a half years. Previous courses concentrated primarily on the basics of algebraic topology, such as homology and cohomology, and their applications to the classification of manifolds and the computation of homotopy groups and cohomology rings.\nThe tools in the form of algebraic structures and theorems that we learned in these coureses, like homology, work well with finite CW-complexes and their finite coverings, after all we are just dealing with finitely generated modules in these cases and concepts like determinants and betti numbers are well defined. However, when we want to study infinite CW-complexes, we need to use more sophisticated tools, such as \\(\\ell^2\\)-Invariants, to understand the topology of these spaces. Something interesting happens, when we look at covering spaces of finite CW-complexes. By the Galois correspondence, we can associate a covering space \\(\\bar X\\) with a subgroup \\(H\\) of the fundamental group \\(G\\) of a base space \\(X\\).(see Hatcher 2010a, Proposition 1.38) Now, we have a group action of \\(G\\) on \\(\\bar X\\) and this added structure allows us to define the \\(\\ell^2\\) betti numbers \\(b_i^{(2)}(H \\curvearrowright \\bar X)\\), \\(\\ell^2\\) homology groups \\(H_i^{(2)}(H \\curvearrowright \\bar X)\\) and much more.\nLet us build some intuition before we proceed though. Consider the base space \\(X=S^1\\), and a \\(d\\) sheeted covering \\(\\bar X_d\\). The fundamental group of \\(X\\) is \\(\\Z\\) and the fundamental group of \\(\\bar X_d\\) is \\(\\Z/d\\Z\\). An early result in the study of \\(\\ell^2\\)-Invariants is that for \\(d\\)-sheeted coverings \\(\\bar X_d \\to X\\), the \\(\\ell^2\\)-betti numbers of \\(\\bar X_d\\) are \\(b_i^{(2)}(\\Z/d\\Z\\curvearrowright\\bar X_d) = b_i(\\bar X_d) / |\\Z/d\\Z| = b_i(\\bar X_d) / d\\). This is quite astounding, as betti numbers are commonly seen as “counting the number of \\(i\\)-dimensional holes” in a space, but here we see that the \\(\\ell^2\\)-betti numbers are not integers, but rational numbers. So, geometrically, what does it mean for a space to have “one third of a hole”? Let us investigate for the case \\(d=3\\).\n\n\nShow the code\n# 3d plotly plot of a a circle and a 3-sheeted covering right next to it\nimport plotly.graph_objects as go\nimport numpy as np\n# S^1\ndef s1()-&gt;(np.ndarray, np.ndarray, np.ndarray):\n    theta = np.linspace(0, 2*np.pi, 100)\n    x = np.cos(theta)\n    y = np.sin(theta)\n    z = np.zeros(100)\n    return x, y, z\n# 3-sheeted covering\ndef covering(sheets: int, handlestart: float = 1/8, subsections=100):\n    theta = np.linspace(0, (sheets-handlestart)*2*np.pi, subsections)\n    x = np.cos(theta)\n    y = np.sin(theta)\n    z = theta/(2*np.pi)\n    # Add a small handle from (1,0,0) to (1,0,`sheets`) in a small bow.\n    # This handle is just here to show that this covering is still homeomorphic to S^1.\n    # The preimages of (1,0,0) therefor would still be a discrete set of `sheets` points, not a line.\n    x = np.append(x, ( lambda v : (1-v**6)/10 )(np.linspace(-1,1, subsections)) + np.cos(np.linspace((sheets-handlestart)*2*np.pi, sheets*2*np.pi, subsections)))\n    y = np.append(y, ( lambda v : (1-v**6)/10 )(np.linspace(-1,1, subsections)) + np.sin(np.linspace((sheets-handlestart)*2*np.pi, sheets*2*np.pi, subsections)))\n    z = np.append(z, ( lambda v : (1-np.arctan(10*v)/np.arctan(10))*(sheets-handlestart)/2 )( np.linspace(-1, 1, subsections) ))\n    return x,y,z\n# draw the plot\nfig = go.Figure()\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='S^1'))(s1()))\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name=f'{3}-sheeted covering'))(covering(3)))\nfig.show()\n\n\n                                                \n\n\nIt is clear, that the betti numbers of the circle \\(S^1\\) are \\(b_0(S^1) = 1\\) and \\(b_1(S^1) = 1\\). The same is the case for any \\(n\\)-sheeted covering. In particular, we have \\(b_0(\\bar X_3) = 1\\) and \\(b_1(\\bar X_3) = 1\\). When we take a look at the \\(\\ell^2\\)-betti numbers, we must take into account the action of the deck transformation group(see Hatcher 2010b) \\(\\text{Deck}(p) = \\Z/3\\Z\\) on \\(\\bar X_3\\), where \\(p: \\bar X_d \\to X\\) is the canonical projection.\n\n\nShow the code\nimport plotly.express as px\nimport numpy as np\nimport pandas as pd\n\n# Function to generate circle coordinates for a given t of rotation around the x-axis\ndef get_frame(t):\n    x,y,z = covering(3)\n    x = (1-t)*x+t*x/np.hypot(x,y)\n    y = (1-t)*y+t*y/np.hypot(x,y)\n    z = z*(1-t)\n    return x, y, z\n\n# Generate data for each frame\nts = np.linspace(0, 1, 20)\ndf = pd.DataFrame()\n\nfor t in ts:\n    x, y, z = get_frame(t)\n    temp_df = pd.DataFrame({'x': x, 'y': y, 'z': z, 't': t})\n    df = pd.concat([df, temp_df])\n\n# Initial plot using Plotly Express\nfig = px.line_3d(df, x='x', y='y', z='z', animation_frame='t')\n\n# Fixing the axis ranges\nfig.update_layout(\n    scene=dict(\n        xaxis=dict(range=[-1.3,1.3], autorange=False),\n        yaxis=dict(range=[-1.3,1.3], autorange=False),\n        zaxis=dict(range=[0,3], autorange=False),\n        aspectmode='cube',  # This ensures equal aspect ratio for all axes\n    ),\n    title=\"Homotopy between id and p\",\n    updatemenus=[{\n        \"buttons\": [\n            {\n                \"args\": [None, {\"frame\": {\"duration\": 50, \"redraw\": True}, \"fromcurrent\": True}],\n                \"label\": \"Play\",\n                \"method\": \"animate\"\n            },\n            {\n                \"args\": [[None], {\"frame\": {\"duration\": 0, \"redraw\": True}, \"mode\": \"immediate\", \"transition\": {\"duration\": 0}}],\n                \"label\": \"Pause\",\n                \"method\": \"animate\"\n            }\n        ],\n        \"direction\": \"left\",\n        \"pad\": {\"r\": 10, \"t\": 87},\n        \"showactive\": False,\n        \"type\": \"buttons\",\n        \"x\": 0.1,\n        \"xanchor\": \"right\",\n        \"y\": 0,\n        \"yanchor\": \"top\"\n    }],\n    sliders=[{\n        \"steps\": [{\"args\": [[f\"{t}\"], {\"frame\": {\"duration\": 50, \"redraw\": True}, \"mode\": \"immediate\"}], \n                   \"label\": f\"{t}\", \"method\": \"animate\"} for t in ts],\n    }]\n)\n# Show figure\nfig.show()\n\n\n                                                \n\n\nMaybe it is already somewhat obvious, that there is a canonical group action from \\(\\Z/3\\Z\\) on \\(\\bar X_3\\). This action, the deck transformation, permutes the three preimages of each point in \\(S^1\\) using Cayley’s theorem. The result of applying the deck transformation to \\(\\bar X_3\\) therefore is a 3-sheeted covering of \\(S^1\\) again and is an isomorphism of covering spaces from \\(\\bar X_3\\) to \\(\\bar X_3\\). As an example, let us consider some point \\(x\\) on \\(\\bar X_3\\). \\(\\text{Deck}(p) \\cong \\Z/3\\Z \\cong \\langle g | g^3 = 0\\rangle\\) acts on \\(x\\) by \\(g.x = x + 1\\), if \\(x\\) is not in the topmost sheet, otherwise it pushes \\(x\\) down to the bottom sheet, assuming we embed \\(\\bar X_3\\) into \\(\\R^3\\) in the obvious way. In the following plot, we can see what happens to both a single point and the whole covering space under the action of the deck transformation. From left to right, we apply \\(g\\) not at all, once and then twice.\n\n\nShow the code\nfrom plotly.subplots import make_subplots\n# the individual point we want to track under the action of the deck transformation\nangle = np.pi*7/8\npoint = ( \n    np.cos(angle),\n    np.sin(angle),\n    angle/(2*np.pi)\n )\n# group action. Because Z/3Z is cyclic, we only need to define the generator\ng = lambda v: (v[0],v[1],v[2]+1 if v[2] &lt; 2 else 0)\n\n# covering [0]\nfig = make_subplots(rows=1, cols=3, specs=[[{'type': 'scene'}, {'type': 'scene'}, {'type': 'scene'}]])\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='[0]'))(covering(3)), row=1, col=1)\n# add a little red dot to show what happens to one individual point\nfig.add_trace(go.Scatter3d(x=[point[0]], y=[point[1]], z=[point[2]], mode='markers', name=\"x\", marker=dict(size=5, color='red')), row=1, col=1)\n\n# covering [1]\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='[1]'))(covering(3, 0, 100)), row=1, col=2)\nfig.add_trace(go.Scatter3d(x=[g(point)[0]], y=[g(point)[1]], z=[g(point)[2]], mode='markers', name=\"g.x\", marker=dict(size=5, color='red')), row=1, col=2)\n\n# covering [2]\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='[2]'))(covering(3, 1/8, 100)), row=1, col=3)\nfig.add_trace(go.Scatter3d(x=[g(g(point))[0]], y=[g(g(point))[1]], z=[g(g(point))[2]], mode='markers', name=\"g.g.x\", marker=dict(size=5, color='red')), row=1, col=3)\n\n\n# legend\nfig.update_layout(\n    title=\"Group action of the cyclic group with three elements on our covering space\",\n)\nfig.show()\n\n\n                                                \n\n\nIt seems that \\(\\ell^2\\)-betti numbers somehow measure “how much each symmetry contributes to the betti-number”, but we still need to make this precise. In this example however, there are three symmetries, \\(b_1(X_3) = 1\\) and \\(b_1(\\Z/3\\Z\\curvearrowright X_3) = 1/3\\), so our intuition kinda makes sense.\n\n\nOne of the main goals in this lecture was for us to reach Lück’s theorem:\n\nLück’s theorem: Let \\(X\\) be a connected, compact CW-complex whose fundamental group \\(G=\\pi_1(X)\\) is residually finite. Then for every residual chain \\((G_i)\\) in \\(G\\) and every \\(n\\ge 0\\) we have \\[\\lim_{i\\to\\infty} \\frac{b_n^{(2)}(\\bar X_i)}{[G:G_i]} = b_n^{(2)}(G\\curvearrowright \\tilde X)\\] where \\(\\bar X_i \\to X\\) is the covering space associated with \\(G_i\\) and \\(\\tilde X\\) is the universal covering space of \\(X\\).\n\nFor clearance, the definition of a residual chain is as follows:\n\nDefinition 1 A sequence \\(G=G_0 \\ge G_1 \\ge G_2 \\ge \\dots\\) of subgroups of a group \\(G\\) is called a residual chain if for each \\(i\\ge 0\\) the index \\([G:G_i]\\) is finite and the intersection \\(\\bigcap_{i\\ge 0} G_i = \\{1\\}\\).\n\nSo a simple and fitting example of a residual chain would be the sequence \\(G_i = \\Z/2^i\\Z\\) for \\(i\\ge 1\\) and \\(G_0 = \\Z\\) in the case of \\(G=\\Z\\), as we had before with \\(S^1\\) and its universal covering space \\(\\tilde X = \\R\\). By plugging in Lück’s theorem, we get:\n\\[\n\\begin{align*}\n& \\lim_{i\\to\\infty} \\frac{b_n^{(2)}(\\bar X_i)}{[G:G_i]} &= b_n^{(2)}(G\\curvearrowright \\tilde X) \\\\\n\\Leftrightarrow& \\lim_{i\\to\\infty} \\frac{b_n^{(2)}(\\bar X_i)}{2^i} &= b_n^{(2)}(\\Z\\curvearrowright \\R) \\\\\n\\Leftrightarrow& \\lim_{i\\to\\infty} \\frac{\\frac{1}{2^i}}{2^i} &= b_n^{(2)}(\\Z\\curvearrowright \\R) \\\\\n\\Leftrightarrow& 0\n\\end{align*}\n\\]\nIn fact, we can generalize this to \\(b_n^{(2)}(\\tilde { \\mathbb{T}^k }) = 0\\), where \\(\\mathbb{T}^k\\) is the \\(k\\)-dimensional torus and therefor \\(\\tilde { \\mathbb{T}^k } \\cong \\R^k\\), which is in stark contrast to the usual betti numbers \\(b_n(\\tilde { \\mathbb{T}^k }) = \\binom{k}{n}\\)."
  },
  {
    "objectID": "posts/l2-invariants/index.html#introduction",
    "href": "posts/l2-invariants/index.html#introduction",
    "title": "\\(\\ell^2\\)-Invariants",
    "section": "",
    "text": "This semester (WiSe 2023/24) I took a course about \\(\\ell^2\\)-Invariants(see Jun.-Prof. Dr. H. Kammeyer 2024) at the University of Düsseldorf. As a reminder, \\(\\ell^2\\) is the Hibert space of square-summable sequences of complex numbers. Meaning, a sequence \\((a_n\\in\\C)_{n=0}^\\infty\\) is in \\(\\ell^2\\) if and only if \\(\\sum_{n=0}^\\infty |a_n|^2 &lt; \\infty\\). By defining an inner product on \\(\\ell^2\\) as \\(\\langle a, b \\rangle = \\sum_{n=0}^\\infty a_n \\overline{b_n}\\), we make \\(\\ell^2\\) to a complete complex inner product space, i.e. a Hilbert space.\nFor context, this course was part of my master’s degree in mathematics and it was the culmination of a series of courses about Algebraic Topology, which I attended for the past two and a half years. Previous courses concentrated primarily on the basics of algebraic topology, such as homology and cohomology, and their applications to the classification of manifolds and the computation of homotopy groups and cohomology rings.\nThe tools in the form of algebraic structures and theorems that we learned in these coureses, like homology, work well with finite CW-complexes and their finite coverings, after all we are just dealing with finitely generated modules in these cases and concepts like determinants and betti numbers are well defined. However, when we want to study infinite CW-complexes, we need to use more sophisticated tools, such as \\(\\ell^2\\)-Invariants, to understand the topology of these spaces. Something interesting happens, when we look at covering spaces of finite CW-complexes. By the Galois correspondence, we can associate a covering space \\(\\bar X\\) with a subgroup \\(H\\) of the fundamental group \\(G\\) of a base space \\(X\\).(see Hatcher 2010a, Proposition 1.38) Now, we have a group action of \\(G\\) on \\(\\bar X\\) and this added structure allows us to define the \\(\\ell^2\\) betti numbers \\(b_i^{(2)}(H \\curvearrowright \\bar X)\\), \\(\\ell^2\\) homology groups \\(H_i^{(2)}(H \\curvearrowright \\bar X)\\) and much more.\nLet us build some intuition before we proceed though. Consider the base space \\(X=S^1\\), and a \\(d\\) sheeted covering \\(\\bar X_d\\). The fundamental group of \\(X\\) is \\(\\Z\\) and the fundamental group of \\(\\bar X_d\\) is \\(\\Z/d\\Z\\). An early result in the study of \\(\\ell^2\\)-Invariants is that for \\(d\\)-sheeted coverings \\(\\bar X_d \\to X\\), the \\(\\ell^2\\)-betti numbers of \\(\\bar X_d\\) are \\(b_i^{(2)}(\\Z/d\\Z\\curvearrowright\\bar X_d) = b_i(\\bar X_d) / |\\Z/d\\Z| = b_i(\\bar X_d) / d\\). This is quite astounding, as betti numbers are commonly seen as “counting the number of \\(i\\)-dimensional holes” in a space, but here we see that the \\(\\ell^2\\)-betti numbers are not integers, but rational numbers. So, geometrically, what does it mean for a space to have “one third of a hole”? Let us investigate for the case \\(d=3\\).\n\n\nShow the code\n# 3d plotly plot of a a circle and a 3-sheeted covering right next to it\nimport plotly.graph_objects as go\nimport numpy as np\n# S^1\ndef s1()-&gt;(np.ndarray, np.ndarray, np.ndarray):\n    theta = np.linspace(0, 2*np.pi, 100)\n    x = np.cos(theta)\n    y = np.sin(theta)\n    z = np.zeros(100)\n    return x, y, z\n# 3-sheeted covering\ndef covering(sheets: int, handlestart: float = 1/8, subsections=100):\n    theta = np.linspace(0, (sheets-handlestart)*2*np.pi, subsections)\n    x = np.cos(theta)\n    y = np.sin(theta)\n    z = theta/(2*np.pi)\n    # Add a small handle from (1,0,0) to (1,0,`sheets`) in a small bow.\n    # This handle is just here to show that this covering is still homeomorphic to S^1.\n    # The preimages of (1,0,0) therefor would still be a discrete set of `sheets` points, not a line.\n    x = np.append(x, ( lambda v : (1-v**6)/10 )(np.linspace(-1,1, subsections)) + np.cos(np.linspace((sheets-handlestart)*2*np.pi, sheets*2*np.pi, subsections)))\n    y = np.append(y, ( lambda v : (1-v**6)/10 )(np.linspace(-1,1, subsections)) + np.sin(np.linspace((sheets-handlestart)*2*np.pi, sheets*2*np.pi, subsections)))\n    z = np.append(z, ( lambda v : (1-np.arctan(10*v)/np.arctan(10))*(sheets-handlestart)/2 )( np.linspace(-1, 1, subsections) ))\n    return x,y,z\n# draw the plot\nfig = go.Figure()\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='S^1'))(s1()))\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name=f'{3}-sheeted covering'))(covering(3)))\nfig.show()\n\n\n                                                \n\n\nIt is clear, that the betti numbers of the circle \\(S^1\\) are \\(b_0(S^1) = 1\\) and \\(b_1(S^1) = 1\\). The same is the case for any \\(n\\)-sheeted covering. In particular, we have \\(b_0(\\bar X_3) = 1\\) and \\(b_1(\\bar X_3) = 1\\). When we take a look at the \\(\\ell^2\\)-betti numbers, we must take into account the action of the deck transformation group(see Hatcher 2010b) \\(\\text{Deck}(p) = \\Z/3\\Z\\) on \\(\\bar X_3\\), where \\(p: \\bar X_d \\to X\\) is the canonical projection.\n\n\nShow the code\nimport plotly.express as px\nimport numpy as np\nimport pandas as pd\n\n# Function to generate circle coordinates for a given t of rotation around the x-axis\ndef get_frame(t):\n    x,y,z = covering(3)\n    x = (1-t)*x+t*x/np.hypot(x,y)\n    y = (1-t)*y+t*y/np.hypot(x,y)\n    z = z*(1-t)\n    return x, y, z\n\n# Generate data for each frame\nts = np.linspace(0, 1, 20)\ndf = pd.DataFrame()\n\nfor t in ts:\n    x, y, z = get_frame(t)\n    temp_df = pd.DataFrame({'x': x, 'y': y, 'z': z, 't': t})\n    df = pd.concat([df, temp_df])\n\n# Initial plot using Plotly Express\nfig = px.line_3d(df, x='x', y='y', z='z', animation_frame='t')\n\n# Fixing the axis ranges\nfig.update_layout(\n    scene=dict(\n        xaxis=dict(range=[-1.3,1.3], autorange=False),\n        yaxis=dict(range=[-1.3,1.3], autorange=False),\n        zaxis=dict(range=[0,3], autorange=False),\n        aspectmode='cube',  # This ensures equal aspect ratio for all axes\n    ),\n    title=\"Homotopy between id and p\",\n    updatemenus=[{\n        \"buttons\": [\n            {\n                \"args\": [None, {\"frame\": {\"duration\": 50, \"redraw\": True}, \"fromcurrent\": True}],\n                \"label\": \"Play\",\n                \"method\": \"animate\"\n            },\n            {\n                \"args\": [[None], {\"frame\": {\"duration\": 0, \"redraw\": True}, \"mode\": \"immediate\", \"transition\": {\"duration\": 0}}],\n                \"label\": \"Pause\",\n                \"method\": \"animate\"\n            }\n        ],\n        \"direction\": \"left\",\n        \"pad\": {\"r\": 10, \"t\": 87},\n        \"showactive\": False,\n        \"type\": \"buttons\",\n        \"x\": 0.1,\n        \"xanchor\": \"right\",\n        \"y\": 0,\n        \"yanchor\": \"top\"\n    }],\n    sliders=[{\n        \"steps\": [{\"args\": [[f\"{t}\"], {\"frame\": {\"duration\": 50, \"redraw\": True}, \"mode\": \"immediate\"}], \n                   \"label\": f\"{t}\", \"method\": \"animate\"} for t in ts],\n    }]\n)\n# Show figure\nfig.show()\n\n\n                                                \n\n\nMaybe it is already somewhat obvious, that there is a canonical group action from \\(\\Z/3\\Z\\) on \\(\\bar X_3\\). This action, the deck transformation, permutes the three preimages of each point in \\(S^1\\) using Cayley’s theorem. The result of applying the deck transformation to \\(\\bar X_3\\) therefore is a 3-sheeted covering of \\(S^1\\) again and is an isomorphism of covering spaces from \\(\\bar X_3\\) to \\(\\bar X_3\\). As an example, let us consider some point \\(x\\) on \\(\\bar X_3\\). \\(\\text{Deck}(p) \\cong \\Z/3\\Z \\cong \\langle g | g^3 = 0\\rangle\\) acts on \\(x\\) by \\(g.x = x + 1\\), if \\(x\\) is not in the topmost sheet, otherwise it pushes \\(x\\) down to the bottom sheet, assuming we embed \\(\\bar X_3\\) into \\(\\R^3\\) in the obvious way. In the following plot, we can see what happens to both a single point and the whole covering space under the action of the deck transformation. From left to right, we apply \\(g\\) not at all, once and then twice.\n\n\nShow the code\nfrom plotly.subplots import make_subplots\n# the individual point we want to track under the action of the deck transformation\nangle = np.pi*7/8\npoint = ( \n    np.cos(angle),\n    np.sin(angle),\n    angle/(2*np.pi)\n )\n# group action. Because Z/3Z is cyclic, we only need to define the generator\ng = lambda v: (v[0],v[1],v[2]+1 if v[2] &lt; 2 else 0)\n\n# covering [0]\nfig = make_subplots(rows=1, cols=3, specs=[[{'type': 'scene'}, {'type': 'scene'}, {'type': 'scene'}]])\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='[0]'))(covering(3)), row=1, col=1)\n# add a little red dot to show what happens to one individual point\nfig.add_trace(go.Scatter3d(x=[point[0]], y=[point[1]], z=[point[2]], mode='markers', name=\"x\", marker=dict(size=5, color='red')), row=1, col=1)\n\n# covering [1]\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='[1]'))(covering(3, 0, 100)), row=1, col=2)\nfig.add_trace(go.Scatter3d(x=[g(point)[0]], y=[g(point)[1]], z=[g(point)[2]], mode='markers', name=\"g.x\", marker=dict(size=5, color='red')), row=1, col=2)\n\n# covering [2]\nfig.add_trace((lambda v: go.Scatter3d(x=v[0], y=v[1], z=v[2], mode='lines', name='[2]'))(covering(3, 1/8, 100)), row=1, col=3)\nfig.add_trace(go.Scatter3d(x=[g(g(point))[0]], y=[g(g(point))[1]], z=[g(g(point))[2]], mode='markers', name=\"g.g.x\", marker=dict(size=5, color='red')), row=1, col=3)\n\n\n# legend\nfig.update_layout(\n    title=\"Group action of the cyclic group with three elements on our covering space\",\n)\nfig.show()\n\n\n                                                \n\n\nIt seems that \\(\\ell^2\\)-betti numbers somehow measure “how much each symmetry contributes to the betti-number”, but we still need to make this precise. In this example however, there are three symmetries, \\(b_1(X_3) = 1\\) and \\(b_1(\\Z/3\\Z\\curvearrowright X_3) = 1/3\\), so our intuition kinda makes sense.\n\n\nOne of the main goals in this lecture was for us to reach Lück’s theorem:\n\nLück’s theorem: Let \\(X\\) be a connected, compact CW-complex whose fundamental group \\(G=\\pi_1(X)\\) is residually finite. Then for every residual chain \\((G_i)\\) in \\(G\\) and every \\(n\\ge 0\\) we have \\[\\lim_{i\\to\\infty} \\frac{b_n^{(2)}(\\bar X_i)}{[G:G_i]} = b_n^{(2)}(G\\curvearrowright \\tilde X)\\] where \\(\\bar X_i \\to X\\) is the covering space associated with \\(G_i\\) and \\(\\tilde X\\) is the universal covering space of \\(X\\).\n\nFor clearance, the definition of a residual chain is as follows:\n\nDefinition 1 A sequence \\(G=G_0 \\ge G_1 \\ge G_2 \\ge \\dots\\) of subgroups of a group \\(G\\) is called a residual chain if for each \\(i\\ge 0\\) the index \\([G:G_i]\\) is finite and the intersection \\(\\bigcap_{i\\ge 0} G_i = \\{1\\}\\).\n\nSo a simple and fitting example of a residual chain would be the sequence \\(G_i = \\Z/2^i\\Z\\) for \\(i\\ge 1\\) and \\(G_0 = \\Z\\) in the case of \\(G=\\Z\\), as we had before with \\(S^1\\) and its universal covering space \\(\\tilde X = \\R\\). By plugging in Lück’s theorem, we get:\n\\[\n\\begin{align*}\n& \\lim_{i\\to\\infty} \\frac{b_n^{(2)}(\\bar X_i)}{[G:G_i]} &= b_n^{(2)}(G\\curvearrowright \\tilde X) \\\\\n\\Leftrightarrow& \\lim_{i\\to\\infty} \\frac{b_n^{(2)}(\\bar X_i)}{2^i} &= b_n^{(2)}(\\Z\\curvearrowright \\R) \\\\\n\\Leftrightarrow& \\lim_{i\\to\\infty} \\frac{\\frac{1}{2^i}}{2^i} &= b_n^{(2)}(\\Z\\curvearrowright \\R) \\\\\n\\Leftrightarrow& 0\n\\end{align*}\n\\]\nIn fact, we can generalize this to \\(b_n^{(2)}(\\tilde { \\mathbb{T}^k }) = 0\\), where \\(\\mathbb{T}^k\\) is the \\(k\\)-dimensional torus and therefor \\(\\tilde { \\mathbb{T}^k } \\cong \\R^k\\), which is in stark contrast to the usual betti numbers \\(b_n(\\tilde { \\mathbb{T}^k }) = \\binom{k}{n}\\)."
  },
  {
    "objectID": "posts/l2-invariants/index.html#constructing-the-ell2-completion-of-cellular-chain-complexes",
    "href": "posts/l2-invariants/index.html#constructing-the-ell2-completion-of-cellular-chain-complexes",
    "title": "\\(\\ell^2\\)-Invariants",
    "section": "Constructing The \\(\\ell^2\\)-Completion Of Cellular Chain Complexes",
    "text": "Constructing The \\(\\ell^2\\)-Completion Of Cellular Chain Complexes\nInstead of talking only about coverings of CW-complexes, we will now talk about general CW-complexes, which come equipped with a special kind of group action. We will call these \\(G\\)-CW-complexes. The definition of a \\(G\\)-CW-complex is as follows:\n\nDefinition 2 A \\(G\\)-CW-complex is a CW-complex \\(X\\) together with an action by a discrete group \\(G\\) such that each open cell \\(E\\) of \\(X\\) is mapped to another open cell \\(gE\\) by the action of \\(g\\in G\\). If \\(gE\\cap E \\neq \\emptyset\\), then \\(g\\) must fix \\(E\\) pointwise.\n\nThis is a generalisation of the observations we made earlier, as the deck transformation group \\(\\text{Deck}(p)\\) is a discrete group and the action of \\(\\text{Deck}(p)\\) on \\(\\bar X_d\\) is a \\(G\\)-action which satisfies the conditions of the definition.\nBy this definition, we know that open \\(i\\)-cells of any \\(G\\)-CW-complex \\(X\\) are mapped onto open \\(i\\)-cells. Let us recall that a CW-complex by definition allows for a filtration into \\(i\\)-skeletons \\(\\emptyset = X_{-1} \\subseteq X_0 \\subseteq X_1 \\subseteq \\dots \\subseteq X_n = X\\), where each \\(X_i\\) is obtained by attaching \\(i\\)-cells to \\(X_{i-1}\\). Let us also recall the definition of \\(\\TopTwo\\):\n\n Definition of \\(\\TopTwo\\) from (H. Kammeyer 2022)\n\nBecause each CW complex also is a topological space and by the inclusion of the \\(( i-1 )\\)-skeletons into the \\(i\\)-skeletons, we can define the cellular chain complex \\(C_*(X)\\) of a \\(G\\)-CW-complex \\(X\\) as \\(C_i(X) = H_i(X_i, X_{i-1})\\). This construction is similar to how one defines cellular homology for CW-complexes(see H. Kammeyer 2022, Definition 6.21) and the idea here is that we use the fact that \\(X_{i-1} \\to X_i\\) is a cofibration to get an isomorphism between \\(H_i(X_i, X_{i-1})\\) and \\(H_i(X_i/X_{i-1}, X_{i-1}/X_{i-1}) \\cong \\tilde H_i(X_i/X_{i-1})\\) (see H. Kammeyer 2022, Proposition 5.6). In pictures, we can think of \\(C_i(X)\\) as counting the number of \\(i\\)-dimensional holes in \\(X_i\\), after we collapse the \\((i-1)\\)-skeleton to a point as is illustrated in Figure 1 with a torus.\n\n\n\n\n\n\nFigure 1: Construction of \\(C_2(\\mathbb{T})\\) given \\(\\mathbb{T}\\) as a CW-complex with four 2-cells, eight 1-cells and four 0-cells.\n\n\n\nNotice that for each \\(g\\in G\\) we have a homeomorphism in \\(\\TopTwo\\): \\(g: (X_i, X_{i-1}) \\xrightarrow{\\sim} (X_i, X_{i-1})\\). This self-homomorphism induces an automorphism on the homology group \\(H_i(X_i, X_{i-1})\\), because by Definition 2 the action of \\(g\\) on \\(X_i\\) is cellular, meaning \\(g\\) sends each \\(i\\)-cell to exactly one other \\(i\\)-cell or itself. This means, that we can apply each \\(g\\) to some cell \\(i\\)-cells \\(c_i\\) and the result will again be in \\(C_i(X)\\). Furthermore, by construction \\(C_i(X)\\) is an abelian group and as such it is a \\(\\Z\\)-module. Pairing this with the group action, we have that \\(C_i(X)\\) is a left \\(\\Z G\\)-module, where \\(\\Z G\\) is the group ring of \\(G\\) over \\(\\Z\\). This means, for any \\(c\\) in \\(C_i(X)\\), we can define \\(\\left(\\sum_g \\lambda_g g\\right).c \\in C_i(X)\\) for \\(\\lambda_g\\in\\Z\\) and \\(g\\in G\\).\n\nIndependence of the Choice of Filtration\nImplicitly, we made a choice in our construction. When we chose a specific filtration of \\(X\\) into \\(i\\)-skeletons, we also chose a specific cellular chain complex \\(C_*(X)\\). Here comes our group action into play. In Figure 1 as an example we may chose \\(G = C_2\\) to be the cyclic group with two elements and the action of \\(C_2\\) on \\(\\mathbb{T}\\) to be the permutation of the green cell with the brown cell and the red cell with the yellow cell. Esentially \\(C_2\\) acts by mirroring the \\(x\\)-axis as seen in Figure 2.\n\n\n\n\n\n\nFigure 2: The action of \\(C_2\\) on \\(\\mathbb{T}\\)\n\n\n\nThis gives us the following pushout diagram as in Theorem 3.2 (see H. Kammeyer 2019):\n\\[\n\\begin{CD}\n\\coprod_{i\\in I_n} G/H_i \\times S^{n-1} @&gt;q_n&gt;&gt; X_{n-1} \\\\\n@Vi_nVV @Vj_nVV\\\\\n\\coprod_{i\\in I_n} G/H_i \\times D^n @&gt;Q_n&gt;&gt; X_n\n\\end{CD}\n\\]\nThis pushout diagram just tells us that the torus is constructed by attaching \\(G\\)-equivant cells. Here \\(q_n\\) is the map, that attaches the boundary of \\(n\\)-disks to our \\((n-1)\\)-Skeleton. \\(i_n\\) and \\(j_n\\) are the respective inclusion maps. \\(Q_n\\) is the attachment map determining how the \\(n\\)-cells are glued into the \\(n\\)-skeleton. Let us understand what \\(I_n\\) and \\(H_i\\) are next. For that, we first label all our \\(n\\) cells. In this example, we only really care for the \\(n=2\\) case, so let us do that.\n\n\n\n\n\n\nFigure 3: Labeling of the 2-cells of the torus\n\n\n\nLabeling each \\(n\\)-cell gives us an index set \\(J_n := \\{\\cellOne, \\cellTwo, \\cellThree, \\cellFour\\}\\). By cayleys theorem, we know that \\(G\\) is isomorphic to a subgroup of the symmetric group \\(S_4\\) and as such permutes the index set \\(J_n\\), which means we can take a look at the orbit set \\(I_n := G\\backslash J_n = \\{\\cellOne,\\cellThree\\}, \\{\\cellTwo,\\cellFour\\}\\). Well, why would we even want to look at this orbit set? The answer is, that this reduces the number of unique \\(n\\)-cells by taking into account, that we can access all \\(n\\)-cells in the same orbit just by applying our group action!\n\n\n\nThe action of \\(C_2 = \\langle g \\rangle\\) on the 2-cells of the torus\n\n\n\n\n\nRepresentative of the orbit \\(\\{\\cellOne,\\cellThree\\}\\).\n\n\n\n\n\nRepresentative of the orbit \\(\\{\\cellTwo,\\cellFour\\}\\).\n\n\nHow can we reconstruct our space from this information now? Well, each of the representatives is just a copy of \\(D^2\\), a \\(n\\)-disk. If we were to multiply this by \\(G\\), then we might end up with too many \\(n\\)-disks. If, for example, we would have chosen \\(G=V_4=\\langle r, s\\rangle\\) to be the Klein four group, and we would let \\(\\langle r \\rangle \\cong C_2\\) act just as before and \\(\\langle s\\rangle\\) trivially, then by \\(V_4 \\cellTwo = \\{\\cellTwo, \\cellFour\\}\\), but \\(V_4 \\times D^2 \\cong \\coprod^4 D^2\\) and we would end up with four \\(2\\)-disks instead of the two we would have hoped for. To avoid this, we need to take the quotient of \\(G\\) acting on \\(D^2\\) by the stabilizer \\(H_k\\) of a representative of the orbit \\(k\\). In our example with \\(V_4\\), we have \\(H_{\\{\\cellOne, \\cellThree\\}} = H_{\\{\\cellTwo, \\cellFour\\}} = \\langle s\\rangle\\) and therefor \\(V_4/H_{\\{\\cellOne, \\cellThree\\}} \\times D^2 \\cong \\coprod^2 D^2\\). This is the reason, why we have the orbit set \\(I_n\\) and the stabilizer groups \\(H_i\\) in our pushout diagram.\nSo, we really only need one one \\(n\\)-cell for each \\(G\\)-orbit. If we were to do that, we will end up with a cellular basis of our \\(G\\)-CW complex. In our example with \\(G=C_2\\), this would be the case if we were to only have two \\(2\\)-cells: \\(\\cellOne\\cup\\cellTwo\\) and \\(\\cellThree\\cup\\cellFour\\). This yields a \\(\\Z G\\)-isomorphism \\(\\bigoplus_{i\\in I_n} \\Z(G/H_i) \\cong C_*(X)\\) (see H. Kammeyer 2019, Proposition 3.6).\n\n\nThe \\(\\ell^2\\)-Completion\nFinally we can take a look at the \\(\\ell^2\\)-chain completion of \\(C_*(X)\\), which is defined as \\(\\ell^2 G \\otimes_{\\Z G} C_*(X)\\). The \\(\\ell^2\\)-completion of a \\(\\Z G\\)-module \\(M\\) is defined as \\(\\ell^2G \\otimes_{\\Z G} M\\), which is functorial and extends itself to the \\(\\ell^2\\)-chain completion of a \\(G\\)-CW complex \\(X\\). Here, it is important that \\(C_*\\) is functorial also, and as such \\(\\ell^2 G \\otimes_{\\Z G} C_*(X)\\) is functorial as well. This in turn is important, because it means, that the differentials \\(d_*^{(2)}\\) are given as \\(\\id \\otimes d_*\\)."
  },
  {
    "objectID": "posts/l2-invariants/index.html#applications",
    "href": "posts/l2-invariants/index.html#applications",
    "title": "\\(\\ell^2\\)-Invariants",
    "section": "Applications",
    "text": "Applications\nLet us now take a look at some applications of the \\(\\ell^2\\)-completion of cellular chain complexes. We will start with the \\(\\ell^2\\)-homology groups and the \\(\\ell^2\\)-betti numbers of \\(S^\\infty := \\colim_n S^n\\) with the group \\(G:=\\prod_{n=0}^\\infty \\Z/2\\Z\\) acting on it. It can easily be seen that \\(S^\\infty\\) is a \\(G\\)-CW complex, where \\(g = (g_1, g_2, \\dots ) \\in G\\) acts on \\(S^\\infty\\) by letting \\(g_i\\in \\Z/2\\Z\\) permute the two \\(i\\)-cells.\n\n\n\n\n\n\nFigure 4: \\(\\colim_n S^n\\). Here it is easy to see how \\(G\\) acts on \\(S^\\infty\\)\n\n\n\nBy following the familiar pattern of defining homology using our differentials, we can define \\(\\ell^2\\)-homology the same way:\n\\[\nH_n^{(2)}(G\\curvearrowright S^\\infty) := \\ker d_n^{(2)} / \\im d_{n+1}^{(2)}\n\\]\nWe wish to use proposition 3.6 (see H. Kammeyer 2019) to calculate the \\(\\ell^2\\)-homology groups of \\(S^\\infty\\). For that, we need to find a cellular basis of \\(S^\\infty\\). We can do that by taking a look at the orbit set \\(I_n = G\\backslash J_n\\) and the stabilizer groups \\(H_i\\). In this case, we have \\(J_n = \\{\\cellOne_n, \\cellTwo_n\\}\\) and \\(I_n = \\{\\{\\cellOne_n, \\cellTwo_n\\}\\}\\), where \\(\\cellOne_n\\) and \\(\\cellTwo_n\\) are the two \\(n\\)-cells of \\(S^\\infty\\). For each \\(n\\), we therefor only have one orbit. This also tells us what our stabilizer groups are: \\(H_{\\{\\cellOne_n, \\cellTwo_n\\}} = \\prod_{k=1}^{n-1} \\Z / 2\\Z \\times \\{e\\} \\times \\prod_{k=n+1}^\\infty \\Z / 2\\Z\\). One can see this visually quite well: We mirror the \\(n\\)-th basis vector of \\(\\R^\\infty\\) using the \\(n\\)-th component of \\(G\\) and leave the other components untouched. Now, we have two \\(n\\)-cells for each basis vector and these are permuted exactly by the \\(n\\)-th component of \\(G\\). All other components of \\(G\\) leave the \\(n\\)-th basis vector untouched and therefor also the \\(n\\)-th \\(n\\)-cell. Thus, the stabilizer group of \\(G\\) that leaves the \\(n\\)-cells untouched is exactly the subgroup of \\(G\\) that leaves the \\(n\\)-th basis vector untouched.\nBy proposition 3.6, we now have \\(C_n(S^\\infty) \\cong \\bigoplus_{i\\in I_n} \\Z(G/H_i) = \\Z ( \\prod_{k=1}^\\infty ( \\Z / 2\\Z ) / ( \\prod_{k=1}^{n-1} \\Z / 2\\Z \\times \\{e\\} \\times \\prod_{k=n+1}^\\infty \\Z / 2\\Z ) ) \\cong \\Z(\\Z / 2\\Z )\\). Now, we only need to calculate the \\(\\ell^2\\)-completion by taking the tensor product with \\(\\ell^2 G\\). We thus get by proposition 3.7 (see H. Kammeyer 2019) that \\(\\ell^2 G \\otimes_{\\Z G} C_n(S^\\infty) \\cong \\ell^2 G \\otimes_{\\Z G} \\Z(\\Z / 2\\Z ) \\cong \\ell^2(\\Z / 2\\Z ) \\cong \\C[\\iota]/(\\iota^2-1)\\). The differentials \\(d_n^{(2)}\\) are given as \\(\\id \\otimes d_n\\). For \\(n&gt;0\\) we know, that \\(d_n\\) cannot be surjective, because \\(d_n(\\cellOne_n)\\) must be one of \\(\\pm\\cellOne_{n-1}+\\cellTwo_{n-1}\\) or \\(\\pm\\cellOne_{n-1}-\\cellTwo_{n-1}\\) and the same holds for \\(d_n(\\cellTwo_n)\\). No matter which of these options holds for \\(\\cellOne_n\\) and \\(\\cellTwo_n\\), we have that \\(\\cellOne_{n-1}, \\cellTwo_{n-1} \\notin \\im d_n\\). For the sake of convenience, we may choose the CW structure of \\(S^\\infty\\) such that \\(d_n(\\cellOne_n) = d_n(\\cellTwo_n) = -\\cellOne_{n-1}+\\cellTwo_{n-1}\\) for \\(n\\ge 1\\).\n\n\nShow the code\nimport plotly.graph_objects as go\n\ndef get_frame_line1(t):\n    t = t if t &lt;= 1 else 1\n    t = t if t &gt;= 0 else 0\n    x = -np.sin(np.linspace(-np.pi,t*np.pi-np.pi,100))\n    y = 0*np.linspace(-np.pi,t*np.pi-np.pi,100)\n    z = np.cos(np.linspace(-np.pi,t*np.pi-np.pi,100))\n    return x, y, z\n\ndef get_frame_line2(t):\n    t = t if t &lt;= 1 else 1\n    t = t if t &gt;= 0 else 0\n    x = np.sin(np.linspace(-np.pi,t*np.pi-np.pi,100))\n    y = 0*np.linspace(-np.pi,t*np.pi-np.pi,100)\n    z = np.cos(np.linspace(-np.pi,t*np.pi-np.pi,100))\n    return x, y, z\n\ndef get_frame_surface1(t):\n    t = t if t &lt;= 1 else 1\n    t = t if t &gt;= 0 else 0\n    if t == 0:\n        x = 0*np.linspace(-1, 1, 100)\n        z = 0*np.linspace(-1, 1, 100)\n        x, z = np.meshgrid(x, z)\n        y = 0 * x\n        return x, y, z\n    # slice of a disk that slowly increases its angle\n    # kinda like a pizza slice\n    # top is (0,0,1), bottom is (0,0,0)\n    # grows along the surface spanned by (1,0,0) and (0,0,1)\n\n    # Define the radial and angular grids\n    theta = np.linspace(-t*np.pi*2 -np.pi/2, -np.pi/2, 100)\n    phi = np.linspace(0, np.pi / 2, 100)\n    theta, phi = np.meshgrid(theta, phi)\n\n    # Spherical to Cartesian coordinates conversion\n    x = np.sin(phi) * np.cos(theta)\n    y = np.cos(phi)\n    z = np.sin(phi) * np.sin(theta)\n    return x, y, z\n\n\ndef get_frame_surface2(t):\n    x,y,z = get_frame_surface1(t)\n    y = -y\n    return x,y,z\n\n# Generate data for each frame\nts = np.linspace(0, 1, 100)\nline_df = pd.DataFrame()\nsurface_df = pd.DataFrame()\n\nfor t in ts:\n    x1, y1, z1 = get_frame_line1(2*t)\n    x2, y2, z2 = get_frame_line2(2*t)\n    x3, y3, z3 = get_frame_surface1(4*(t-0.5))\n    x4, y4, z4 = get_frame_surface2(4*(t-0.75))\n\n    temp_line_df = pd.DataFrame({\n        'x1': x1, 'y1': y1, 'z1': z1,\n        'x2': x2, 'y2': y2, 'z2': z2,\n        't': t})\n    line_df = pd.concat([line_df, temp_line_df])\n\n    temp_surface_df = pd.DataFrame({\n        'x3': x3.flatten(), 'y3': y3.flatten(), 'z3': z3.flatten(),\n        'x4': x4.flatten(), 'y4': y4.flatten(), 'z4': z4.flatten(),\n        't': [t] * 10000})  # 10000 = 100x100\n    surface_df = pd.concat([surface_df, temp_surface_df])\n\nframes = []\nfor t in ts:\n    line_row = line_df[line_df['t'] == t]\n    surface_row = surface_df[surface_df['t'] == t]\n    frames.append(go.Frame(\n        data=[\n            go.Scatter3d(x=line_row['x1'], y=line_row['y1'], z=line_row['z1'], mode='lines', line=dict(color='green', width=2)),\n            go.Scatter3d(x=line_row['x2'], y=line_row['y2'], z=line_row['z2'], mode='lines', line=dict(color='red', width=2)),\n            go.Surface(x=surface_row['x3'].values.reshape(100, 100), y=surface_row['y3'].values.reshape(100, 100), z=surface_row['z3'].values.reshape(100, 100), colorscale='reds', showscale=False),\n            go.Surface(x=surface_row['x4'].values.reshape(100, 100), y=surface_row['y4'].values.reshape(100, 100), z=surface_row['z4'].values.reshape(100, 100), colorscale='greens', showscale=False)\n        ],\n        name=str(t)\n    ))\n\n# Create a figure using plotly.graph_objects\nfig = go.Figure(\n    layout=go.Layout(\n        updatemenus=[dict(\n            type=\"buttons\",\n            buttons=[dict(label=\"Play\",\n                          method=\"animate\",\n                          args=[None, {\"frame\": {\"duration\": 75, \"redraw\": True},\n                                       \"fromcurrent\": True}]),\n                    dict(label=\"Pause\",\n                         method=\"animate\",\n                         args=[[None], {\"frame\": {\"duration\": 0, \"redraw\": False},\n                                        \"mode\": \"immediate\",\n                                        \"transition\": {\"duration\": 0}}])],\n            \n        )],\n        sliders=[\n            dict(\n                active=0,\n                steps=[dict(method=\"animate\",\n                            args=[[f\"{t}\"], {\"frame\": {\"duration\": 75, \"redraw\": True},\n                                             \"mode\": \"immediate\",\n                                             \"transition\": {\"duration\": 0}}]) for t in ts]\n            )\n        ]\n    ),\n    frames=frames\n)\n\n# Add initial data\nfig.add_trace(go.Scatter3d(\n    x=line_df['x1'].iloc[0:100], y=line_df['y1'].iloc[0:100], z=line_df['z1'].iloc[0:100],\n    mode='lines', line=dict(color='green', width=2)))\nfig.add_trace(go.Scatter3d(\n    x=line_df['x2'].iloc[0:100], y=line_df['y2'].iloc[0:100], z=line_df['z2'].iloc[0:100],\n    mode='lines', line=dict(color='red', width=2)))\n# surface plots\nfig.add_trace(go.Surface(\n    x=surface_df['x3'].iloc[0:10000].values.reshape(100, 100),\n    y=surface_df['y3'].iloc[0:10000].values.reshape(100, 100),\n    z=surface_df['z3'].iloc[0:10000].values.reshape(100, 100),\n    colorscale='reds', showscale=False))\nfig.add_trace(go.Surface(\n    x=surface_df['x4'].iloc[0:10000].values.reshape(100, 100),\n    y=surface_df['y4'].iloc[0:10000].values.reshape(100, 100),\n    z=surface_df['z4'].iloc[0:10000].values.reshape(100, 100),\n    colorscale='greens', showscale=False))\n\n# Layout configuration\nfig.update_layout(\n    scene=dict(\n        xaxis=dict(range=[-1, 1], autorange=False),\n        yaxis=dict(range=[-1, 1], autorange=False),\n        zaxis=dict(range=[-1, 1], autorange=False),\n    ),\n    title_text=\"Attachment maps for the 1 and 2 cells\",\n)\n\n# Show the figure\nfig.show()\n\n\n                                                \n\n\nWe can now calculate \\(H_0^{(2)}(G\\curvearrowright S^\\infty) = \\ker d_0^{(2)} / \\im d_1^{(2)}\\). We know that \\(\\ker d_0^{(2)} = \\{\\cellOne_0, \\cellTwo_0\\}\\), because \\(d_0^{(2)}(\\cellOne_0) = d_0^{(2)}(\\cellTwo_0) = 0\\). For \\(n\\ge 1\\) we have seen that \\(d_n(\\cellOne_n) = d_n(\\cellTwo_n) = -\\cellOne_{n-1}+\\cellTwo_{n-1}\\) and as such \\(\\ker d_0^{(2)} / \\im d_1^{(2)} \\cong \\C[\\iota]/(\\iota^2-1)\\). For \\(n\\ge 1\\) we can see that \\(H_n^{(2)}(G\\curvearrowright S^\\infty) = 0\\).\nFinally, we can calculate the \\(\\ell^2\\)-Betti numbers:\n\\[\n\\begin{align*}\nb_n^{(2)}(G\\curvearrowright S^\\infty)\n&= \\dim_{\\mathcal{R}G} H_n^{(2)}(G\\curvearrowright S^\\infty) \\\\\n&= \\tr_{\\mathcal{R}G} \\left( \\id_{H_n^{(2)}(G\\curvearrowright S^\\infty)} \\right) \\\\\n&= \\begin{cases}\n    2 & \\text{if } n=0 \\\\\n    0 & \\text{if } n\\ge 1\n\\end{cases}\n&= \\begin{cases} 2 & \\text{if } n=0 \\\\ 0 & \\text{if } n\\ge 1 \\end{cases}\n\\end{align*}\n\\]\nHere \\(\\mathcal{R}(G)\\) denotes the group von Neumann algebra, which is the weak closure of the unital \\(*\\)-subalgebra \\(\\rho(\\C G)\\subset B(\\ell^2 G)\\), where \\(\\rho: \\C G \\to B(\\ell^2 G)\\) is the right regular representation of \\(\\C G\\) on \\(\\ell^2 G\\), given by \\(\\rho : \\C G \\to B(\\ell^2 G), \\&gt; \\rho(h)g = gh\\). The trace \\(\\tr_{\\mathcal{R}G}\\) is the unique trace on \\(\\mathcal{R}(G)\\) that is invariant under the action of \\(G\\) defined by \\(\\tr_{\\mathcal{R}(G)}: \\mathcal{R}(G) \\to \\C, \\&gt; T\\mapsto \\langle e, T e\\rangle\\). Furthermore, \\(B(\\ell^2 G)\\) is the space of bounded operators on \\(\\ell^2 G\\).\nFrom this, we can simply calculate that \\(b_n^{(2)}(G\\curvearrowright S^\\infty) = \\tr_{\\mathcal{R}G} \\left( \\id_{H_n^{(2)}(G\\curvearrowright S^\\infty)} \\right) = \\langle e,  \\id_{H_n^{(2)}(G\\curvearrowright S^\\infty)} e \\rangle = 0\\) for \\(n\\ge 1\\) and \\(b_0^{(2)}(G\\curvearrowright S^\\infty) = \\tr_{\\mathcal{R}G} \\left( \\id_{H_0^{(2)}(G\\curvearrowright S^\\infty)} \\right) = \\langle e,  \\id_{H_0^{(2)}(G\\curvearrowright S^\\infty)} e \\rangle = 2\\)."
  },
  {
    "objectID": "posts/sheaves_in_minecraft/index.html",
    "href": "posts/sheaves_in_minecraft/index.html",
    "title": "Sheaves in Minecraft",
    "section": "",
    "text": "A few days ago, after my introductory class in topology, and right before my class about algebraic geometry, my friend Anastasia and I were asked by fellow topology students about our current topics in algebraic geometry. This then lead to the discussion about sheaves, as they saw my sketch of them in my lecture notes (because I mentioned that I typically only draw geometric sketches of ideas and proofs instead of writing actual sentences like most people).\n\n\n\nWe talked about this diagram\n\n\nAfter some explaining, they seemed to understand the concept somewhat, but I was unable to give them a deeper understanding. I assume this was caused by my inability to relate the importance of this structure to them in a practical way. So after some days, I started to imagine fictional conversations in my spare time where I would try to explain this topic to them again. I especially tried to focus on giving real-world examples of sheaves, which are not exactly linked to algebraic geometry, but, instead convey the idea of tracking data that is connected to open sets. And as I thought about this, I started to imagine video games, which typically provide very natural applications of impressively deep mathematical structures, leading me to relate the game Minecraft to algebraic geometry, or sheaves more exactly."
  },
  {
    "objectID": "posts/sheaves_in_minecraft/index.html#introduction",
    "href": "posts/sheaves_in_minecraft/index.html#introduction",
    "title": "Sheaves in Minecraft",
    "section": "",
    "text": "A few days ago, after my introductory class in topology, and right before my class about algebraic geometry, my friend Anastasia and I were asked by fellow topology students about our current topics in algebraic geometry. This then lead to the discussion about sheaves, as they saw my sketch of them in my lecture notes (because I mentioned that I typically only draw geometric sketches of ideas and proofs instead of writing actual sentences like most people).\n\n\n\nWe talked about this diagram\n\n\nAfter some explaining, they seemed to understand the concept somewhat, but I was unable to give them a deeper understanding. I assume this was caused by my inability to relate the importance of this structure to them in a practical way. So after some days, I started to imagine fictional conversations in my spare time where I would try to explain this topic to them again. I especially tried to focus on giving real-world examples of sheaves, which are not exactly linked to algebraic geometry, but, instead convey the idea of tracking data that is connected to open sets. And as I thought about this, I started to imagine video games, which typically provide very natural applications of impressively deep mathematical structures, leading me to relate the game Minecraft to algebraic geometry, or sheaves more exactly."
  },
  {
    "objectID": "posts/sheaves_in_minecraft/index.html#minecraft-as-a-game",
    "href": "posts/sheaves_in_minecraft/index.html#minecraft-as-a-game",
    "title": "Sheaves in Minecraft",
    "section": "Minecraft as a game",
    "text": "Minecraft as a game\nMinecraft is the most popular game in existence currently. Therefore it is very likely that you, the reader, have heard about it at some point in your life. But here is a quick recap of what Minecraft is and how it works (abstractly).\n\nWhat is Minecraft?\n\n\n\nExample view of minecraft\n\n\nIn Minecraft, you start a game as a digital character in a blocky world. There you start to collect resources by mining different materials (in the form of breaking blocks mainly) or slaying enemies which roam your digital world.\n\n\nHow does it technically work?\nNow the interesting part for us at least would be, how the game stores this world and its inhabitants. We know that the blocks are arranged in a lattice pattern which happens to be \\(\\mathbb{Z}^3\\) and because each block can be identified by its type (air, grass, dirt, wood, …) and there are just a finite number of unique blocks, we can store the blocky part of a Minecraft world as a subset \\(M\\subset \\mathbb{Z}^3\\times\\mathbb{N}\\) by using a bijective mapping from the types of blocks to \\(\\mathbb{N}=\\{0,1,2,\\dots\\}\\).\nNow how can Minecraft be able to process infinitely many blocks and render them to a screen? The answer is that this would be impossible, because traversing every block in an infinite Minecraft world (which most Minecraft worlds are) would take a very long time, let alone rendering them. This would be impossible to render at a stable 30FPS and the developers at Mojang decided to split the Minecraft world into chunks of \\(16\\times 16\\times 256\\) (here we can neglect the last coordinate of our tuples in \\(M\\), because the number of different blocks is small enough that a computer can traverse them easily).\n \nThese subsets of the world \\(C_{x,y,z}\\subset M\\subset \\mathbb{Z}^3\\times\\mathbb{N}\\) are called chunks and exist for each \\(x,y \\in 16\\mathbb{Z}, \\&gt; z\\in 256\\mathbb{Z}\\) (technically the \\(z\\) is fixed to \\(0\\) because Minecraft has a finite height of \\(256\\) blocks, but we will abstract/future proof a bit for now).\n\nSo why are these chunks important for us? How do they relate to sheaves? Well, these \\(C_{x,y,z}\\) form a basis of a topology on \\(M\\) if we name the “chunks” not “chunks” but “open sets” instead! This is quite natural because Minecraft creates a union of these chunks (the number of which is free for the user to decide, therefore possibly infinite) and then renders this union of chunks to the screen. This union of chunks would not be considered a chunk in Minecrafts’ code, but we will refer to the union of chunks as “open set” nonetheless because this gives us our topological structure on \\(M\\). (Bonus: to really prove that the \\(C_{x,y,z}\\) form a topological basis, one must show that the finite intersection of open sets must also be an open set. The proof is quite trivial but left as an exercise to the reader.)\n\n\nSo we have a topological space on our Minecraft world \\(M\\), what now?\nAfter having done all of this for the sake of rendering parts of our world on a computer in a finite time, we get some fundamentally needed game mechanics (which are not obviously related to the rendering pipeline) for free!\nLike for example when the player wants to go to sleep in the game. Minecraft first checks if the player does not have any hostile entities in the current chunk. Therefore the game must calculate the set of all entities currently in the game world, which are also in the currently inhabited chunk.\nFor this, Minecraft stores all entities as tuples \\(e\\in\\mathbb{R}^3\\times\\mathbb{N}\\), where \\(\\mathbb{N}\\) again denotes the type of enemy. But now, minecraft also has a functor \\(\\mathcal{F}: (\\frac{\\text{open}}{M})\\to \\mathcal{E}\\), where \\(\\mathcal{E}\\) is the category of entities, which has as objects just sets of entities and as morphisms the surjective maps \\(\\phi: V \\twoheadrightarrow V'\\subset V\\) for \\(V, V'\\in \\mathcal{E}\\) and \\(\\left(\\frac{\\text{open}}{M}\\right)\\) denotes the category of open sets over \\(M\\) created by set inclusion as well.\nIn tradition to the notation used by my professor Schröer, I will denote the application of this functor as \\(\\Gamma(U, \\mathcal{F})=V\\).\n\n\nA quick recap in simple terms\nWhat we did now, was define a mapping from the open sets in our Minecraft world to the sets of entities. This just allows us to ask the following question using the mathematical/computer language:\n\nWhich entities (like zombies, skeleton, player, …) are inside the collection of the following chunks: \\(C_{x_1, y_1, z_1}, C_{x_2, y_2, z_2}, \\dots\\) ?\n\nAnd the formulation in mathematical lingo would be:\n\\[\\begin{equation}\n\\Gamma(\\bigcup_{i\\in I} C_{x_i, y_i, z_i}, \\mathcal{F})=V\n\\end{equation}\\]\nwhere \\(V\\) is the set of entities we are looking for. We can say as a rule, that for our purposes \\(\\mathcal{F}\\) must suffice the following condition:\n\nFor each open set \\(U\\) of \\(M\\), we have the set \\(\\Gamma(U, \\mathcal{F})\\).\n\n\n\nBut who needs the structure of a sheaf for that? Doesn’t a function suffice?\n\n\n\nWell yes, but actually no\n\n\nThe problem with just mapping open sets of our Minecraft world to sets of entities raises the problem of restricting our open set but increasing our number of entities therein. Imagine the following. You have your Minecraft map and play the game with your character \\(p\\) inside said map. Now you wish to poll the number of entities that are located in your current chunk (the one your player resides in) and the ones adjacent to your current chunk. This would give you in total \\(9\\) chunks in which you poll for entities. Because you wish to let your character sleep in the game and the game does not let your character sleep if there are any monsters (which are a subset of entities) near your bed, you need to check if \\(\\Gamma(V, \\mathcal{F})\\) has any monster in it (where \\(V\\) is the chunk the player is in and the adjacent chunks). So now the game says everything is fine because \\(\\Gamma(V, \\mathcal{F}) = \\{p\\}\\), your player is the only entity in these chunks and you can go to bed. But when you wake up in Minecraft to your dismay you are getting attacked by a zombie, because actually there was one more entity nearby. There was indeed one zombie \\(z \\in \\Gamma(V', \\mathcal{F})\\) where \\(V'\\subset V\\) is just the player’s current chunk. This problem/bug occurred because the mapping which shows entities residing in an open set of our topology did not respect restriction mappings. This means, even if one takes the subset of an open set, the correlating entities in this subset need not be a subset of the entities correlating to the superset. Indeed, in our case we had \\(V'\\subset V\\) but \\(\\Gamma(V',\\mathcal{F})=\\{p,z\\}\\supset \\{p\\}=\\Gamma(V,\\mathcal{F})\\)\nWe can solve this issue by requesting our function \\(\\mathcal{F}\\) must fulfill the following criteria:\n\nFor each inclusion \\(V'\\subset V\\) there must be a function \\(\\text{res}^{V}_{V'}:\\Gamma(V,\\mathcal{F})\\to\\Gamma(V',\\mathcal{F})\\) \n\\(\\text{res}^{V'}_{V''} \\circ \\text{res}^{V}_{V'} = \\text{res}^{V}_{V''}\\) \n\\(\\text{res}^{V}_{V} = id\\) \n\nThis so far just means, that given some \\(\\Gamma(V,\\mathcal{F})\\) which is the set of entities inside some open set, we can look at smaller open sets’ entities if these open sets are included in the prior open set.\n\n\nThe last problem to solve\nSo now we have done all of this to formalize our notion of entities inside some set of chunks. But there is still some problem in the example we wrote one paragraph before. We still have not solved the problem that given our knowledge of \\(\\Gamma(V,\\mathcal{F})\\) where \\(U\\) is some open set (with the player inside) we want to infer that, open subsets \\(V'\\subset V\\) cannot have more entities or ones, that cannot be found inside \\(V\\).\nThe problem we are facing is that we are missing the sheaf axiom, which completes our requirements from before:\n\nFor each open set \\(U\\) of \\(M\\), we have the set \\(\\Gamma(U, \\mathcal{F})\\).\nFor each inclusion \\(V'\\subset V\\) there must be a function \\(\\text{res}^{V}_{V'}:\\Gamma(V,\\mathcal{F})\\to\\Gamma(V',\\mathcal{F})\\) \n\\(\\text{res}^{V'}_{V''} \\circ \\text{res}^{V}_{V'} = \\text{res}^{V}_{V''}\\) \n\\(\\text{res}^{V}_{V} = id\\) \n\nwhich defines a sheaf. The sheaf axiom now states the following:\n\n(Locality) If \\(\\mathcal{U}=\\bigcup_{i\\in I} U_i\\) is an open covering of an open set \\(U\\) and if \\(s,t\\in\\Gamma(U,\\mathcal{F})\\) with \\(\\text{res}^U_{U_i}(s)=\\text{res}^U_{U_i}(t)\\), then \\(s=t\\)\n(Gluing) If \\(\\mathcal{U}=\\bigcup_{i\\in I} U_i\\) is an open covering of an open set \\(U\\) and \\(s_i\\in U_i\\) for \\(i\\in I\\) holds \\(\\text{res}^{U_i}_{U_i\\cup U_j}(s_i) = \\text{res}^{U_j}_{U_i\\cup U_j}(s_j)\\) then there must be exactly one \\(s\\in\\Gamma(U,\\mathcal{F})\\) with \\(\\text{res}^U_{U_i}(s) = s_j\\)\n\nAnd these basically state, that if there is some entity \\(e'\\) in \\(V'\\subset V\\), ergo \\(e'\\in\\Gamma(V', \\mathcal{F})\\), then there must also be exactly one \\(e\\in\\Gamma(V,\\mathcal{F})\\) which is then equal to \\(e'\\) is we restrict our focus back to \\(V'\\).\nIn our situation with the zombie before, we had looked at an open set \\(V\\) which was defined as the chunk with the player \\(p\\) inside glued together with the chunks adjacent to that one. We said \\(\\Gamma(V,\\mathcal{F})\\) only included the player, because this was the only entity that was mapped from \\(V\\) by \\(\\mathcal{F}\\), but then we said there was actually one zombie \\(z'\\) (another entity) inside \\(V'\\), which we defined as the chunk the player was inside.\nThis clearly violates our sheaf axiom! Because by the gluing property, we must have \\(z\\in\\Gamma(V,\\mathcal{F})\\) as it follows from \\(z'\\in\\Gamma(V',\\mathcal{F})\\) that there needs to be this \\(z\\) with \\(\\text{res}^V_{V'}(z)=z'\\). So we know that because there is an open set with a zombie \\(z'\\) inside, an entity \\(z\\) that looks like this zombie if we restrict our focus to the open set where we found \\(z'\\) must also exist in any open set \\(V\\) that includes \\(V'\\)."
  },
  {
    "objectID": "posts/sheaves_in_minecraft/index.html#conclusion",
    "href": "posts/sheaves_in_minecraft/index.html#conclusion",
    "title": "Sheaves in Minecraft",
    "section": "Conclusion",
    "text": "Conclusion\nThis concept might look daunting at first and maybe even useless because of its’ apparent abstractness. But in fact, we are very far away from some abstract useless construct as I tried to visualize in this blog post. In fact, the construct of a sheaf is quite natural as it canonically allows us to track data attached to open sets (or as is the case in Minecraft: track entities in unions of chunks).\nThis concept can be much further observed though, providing a rich theory not just applicable in algebraic geometry. I will try to publish another post soon where I analyze some art I found particularly interesting using the structures defined in this post while also extending the notions of a sheaf to the ideas of stalks (which in our Minecraft example would allocate the entities in the smallest open set around some point to said point; Or more concretely all the entities in a chunk are returned, if we enter some point inside said chunk) and possibly also the idea of germs.\nUntil then I wish all of you good luck and fun applying abstract math with seemingly no application 😉."
  },
  {
    "objectID": "posts/modeltheory_1/index.html",
    "href": "posts/modeltheory_1/index.html",
    "title": "Modeltheory 1",
    "section": "",
    "text": "This semester, I participate in the course “Modeltheory 1” at the University of Düsseldorf. Further information about the course can be found here. The course closely follewed the book “A Course in Model Theory” by Tent, Ziegler. Model theory is a branch of mathematical logic that deals with the relation between a formal language and its interpretations, or models. This course is the third in a series of courses on model theory. The first course was called “introduction to modeltheory” and the second was a course on “o-minimal structures”, which are a special topic in model theory.\nIn the introductory course, we learned about:\n\n\n\n\n\n\n\nTopic\nDescription\n\n\n\n\nlanguages\nSets of symbols, like the language of groups \\(L_{\\text{Grp}} = \\{e,*,(\\cdot)^{-1}\\}\\)\n\n\nstructures\nInterpretations of the symbols of a language in a given set, like the group \\((0, +, x \\mapsto -x)\\) over the set \\(\\mathbb{Z}\\)\n\n\ntheories\nSets of sentences1 in a language, like the theory of groups \\(T_{\\text{Grp}} = \\{\\forall x \\forall y \\forall z (x * (y * z) = (x * y) * z), \\forall x (x * e = x), \\forall x (x * x^{-1} = e)\\}\\)\n\n\n\nIn the second course, we learned about o-minimal structures, which are notable, because their definable sets are very simple. For example, in the real numbers, the definable sets are exactly the finite unions of points and intervals if we only use the symbols \\(0, 1, +, -, \\cdot, \\leq\\). One of the main results of the course was that the theory of the real numbers with these symbols and the exponential function is o-minimal.\nIn this course, we learned about the following topics:\n\n\n\n\n\n\n\nTopic\nDescription\n\n\n\n\nTypes and saturated structures\nTODO\n\n\nDimension and Morley rank\nTODO\n\n\nImaginary elements\nTODO\n\n\n\nAs an exercise for my upcoming exam in this course, I will write a summary of the topics we learned about and provide some examples and hopefully some code to illustrate the concepts."
  },
  {
    "objectID": "posts/modeltheory_1/index.html#types-and-saturated-structures",
    "href": "posts/modeltheory_1/index.html#types-and-saturated-structures",
    "title": "Modeltheory 1",
    "section": "Types and saturated structures",
    "text": "Types and saturated structures"
  },
  {
    "objectID": "posts/modeltheory_1/index.html#footnotes",
    "href": "posts/modeltheory_1/index.html#footnotes",
    "title": "Modeltheory 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA sentence is a formula without free variables. We wont go into the details of what a formula is, but intuitively it is a string of symbols and variables in our language, that follows some rules.↩︎"
  }
]