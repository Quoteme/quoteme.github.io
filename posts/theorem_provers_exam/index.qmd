---
title: "Automated theorem proving"
author: "Luca Leon Happel"
date: "2024-02-21"
date-modified: "2024-02-21"
categories: ["mathematics", "logic", "automated theorem proving", "lean4", "formal verification"]
bibliography: references.bib
filters:
   - lightbox
lightbox: auto
format:
    html:
        code-fold: true
        code-summary: "Show the code"
image: "thumbnail.svg"
---

::: {.hidden}
$$
\newcommand{\a}{\text{a}}
\newcommand{\b}{\text{b}}
\newcommand{\f}{\text{f}}
\newcommand{\g}{\text{g}}
\newcommand{\T}{\mathbb{T}}
$$
:::

## Introduction

If you are a programmer, most likely you know that feeling you get when you work on your code for too long, that maybe, however unlikely, there is a bug in your code. You have tested it, you have written unit tests, but still, you are not sure. You are not sure if your code is correct. This is where formal verification comes in. Formal verification is the process of proving that a program is correct. This can be done in many ways, but one of the most interesting ways is automated theorem proving. In this article, I will provide a glimpse into automated theorem proving and show you how to use the Lean4 programming language to prove theorems. This is not really intended as an introduction to Lean4 or automated theorem proving, but rather as a demonstration of what I learned after half holding a seminar about it, attending half a year of a course about it at the [university of Düsseldorf](https://www.hhu.de/) and particiating at the conference [Lean for the Curious Mathematician 2023](https://lftcm2023.github.io/).

## From functional programming to automated theorem proving

Lean4 is a functional programming language. This means that it is a programming language that is based on the $\lambda$-calculus. The $\lambda$-calculus is a formal system in mathematical logic for expressing computation based on function abstraction and application using variable binding and substitution. In Lean4, we write programs by defining functions, composing them in clever ways and finally applying them to specific arguemnts. In this regard, Lean4 is very similar to [Haskell](https://www.haskell.org/), about which [I held a talk a year ago](posts/bachelor-seminar-haskell/).

By enriching the $\lambda$-calculus with a sufficiently strong type system like in Lean4, we can use the resulting programming language to write programs that are provably correct. The foundation of this is the [Curry-Howard correspondence](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence), whose motto is "propositions as types, proofs as terms". In $\lambda$-calculus, terms are well-defined mathematical objects as are types.

A quick example here would be:

```{lean4}
def swap {α β : Type} (p : α × β) : β × α := (p.snd, p.fst)

theorem swap_swap {α β : Type} (p : α × β) : swap (swap p) = p :=
  match p with
  | (a, b) => rfl
```

Here we we define a function `{lean4} swap` that swaps the elements of a pair. We then prove that `{lean4} swap` is involutive, i.e. that `{lean4} swap (swap p) = p` for all pairs `p`. The `{lean4} theorem` keyword is used to define a theorem, but is just syntactic sugar for defining a function that represents a proof. Notice that we state our theorem using Lean4's type system and then provide a proof using Lean4's programming language. The proof is verified by the Lean4 compiler, which checks if each step in the program has valid types. If we were to change the proof to the following:

```{lean4}
theorem swap_swap {α β : Type} (p : α × β) : swap (swap p) ≠ p :=
  match p with
  | (a, b) => rfl
```

The Lean4 compiler would throw the following error regarding the `{lean4} rlf` function:

```{lean4}
type mismatch
  rfl
has type
  ?m.149 = ?m.149 : Prop
but is expected to have type
  swap (swap (a, b)) ≠ (a, b) : Prop
```

### Untyped $\lambda$-calculus

Let $V = \{x,y,z, \dots\}$ be a set, which we call the set of variables and let $K = \{\a,\b,\f,\g, \dots\}$ be a set, which we call the set of constants. We can now define the set of terms $\Lambda$ _inductively_ as follows:

| Rule                                                               | Name        |
| ------------------------------------------------------------------ | ----------- |
| If $x \in V$, then $x \in \Lambda$                                 | Variable    |
| If $\f \in K$, then $\f \in \Lambda$                               | Constant    |
| If $s,t \in \Lambda$, then $(st) \in \Lambda$                      | Application |
| If $x \in V$ and $t \in \Lambda$, then $(\lambda x.t) \in \Lambda$ | Abstraction |

Using the notation of the [Backus–Naur form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form), we can define $\Lambda$ succinctly as follows:

$$
\Lambda ::= V \mid K \mid \Lambda \Lambda \mid \lambda V.\Lambda
$$

This strongly resembles the [syntax of Lean4](https://leanprover.github.io/functional_programming_in_lean/getting-to-know/datatypes-and-patterns.html) and also [that of Haskell](https://wiki.haskell.org/Type).

### Simply typed $\lambda$-calculus

In the simply typed $\lambda$-calculus, we enrich the untyped $\lambda$-calculus with a type system. We define the set of types $\T$ _inductively_ using a set of _base types_ $\T_0$ as follows:

1. If $A \in \T_0$, then $A \in \T$
2. If $A,B \in \T$, then $A \to B \in \T$

Using the notation of the [Backus–Naur form](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form) again, we can define $\T$ succinctly as follows:

$$
\T ::= \T_0 \mid \T \to \T
$$

Using the set of types $\T$, we can now define the set of typed terms $\Lambda_\T$ _inductively_ using the Backus–Naur form as follows:

$$
\begin{align*}
\Lambda_\T &::= V \mid K \mid \Lambda_\T \Lambda_\T \mid \lambda V:\T.\Lambda_\T \\
           & \text{where } \\
           & V \text{ is the infinite set of variables } \\
           & K \text{ is the set of constants } \\
\end{align*}
$$

### Type inference