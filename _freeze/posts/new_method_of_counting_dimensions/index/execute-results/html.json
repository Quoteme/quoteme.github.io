{
  "hash": "f1f354622616862b97a45ccb60c6d148",
  "result": {
    "markdown": "---\ntitle: \"A new method to calculate dimension\"\nauthor: \"Luca Leon Happel\"\ndate: \"2020-05-22\"\ncategories: [\"math\", \"fractals\", \"dimension\", \"calculus\", \"geometry\"]\nimage: \"thumbnail.png\"\n---\n\n## Introduction to the Theory\n\nA few days ago, I stumbled upon an article titled Finally We May Have a Path to the Fundamental Theory of Physics... and It's Beautiful by [Stephen Wolfram](https://www.stephenwolfram.com/), an American scientist and the creator of WolframAlpha. His article discusses his new theory in physics, which is based on directed graphs and their transformations under specific rules. For more detailed information, here is the full version: [www.wolframphysics.org/technical-introduction/](www.wolframphysics.org/technical-introduction/).\n\nHis theory notably constructs mathematical spaces from these graphs, essentially nodes interconnected with each other.\n\n## Impact on Dimensionality\n\nThis raises the question of what this theory can reveal about the dimensionality of spaces. Much on this topic can be read in [the article](https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#23_out). In summary, using these graphs, the dimension of a space can be generalized. This generalization can then be extended to other mathematical objects, allowing for an expanded concept of dimension. This enables discussions about \"2.5\"-dimensional spaces or even \"$\\pi$\"-dimensional spaces. Importantly, we're not limited to classical vector spaces made up of tuples (e.g., $\\mathbb{R}^3$); any set equipped with a metric can be used as our space.\n\nThe intriguing aspect here is that this new concept of dimension depends solely on a set and a metric defined on it, but a purely topological space doesn't seem to suffice.\n\n## My Initial Ideas\n\nInitially, translating this concept to metric spaces was quite complex for me. However, in the end, the formulas were essentially the same. I made it unnecessarily complicated for myself by conducting my own research:\n\n<blockquote class=\"imgur-embed-pub\" lang=\"en\" data-id=\"a/3yjeSPI\">\n<a href=\"//imgur.com/a/3yjeSPI\">Meine Ideen zum Dimensionsbegriff</a>\n</blockquote>\n<script async src=\"//s.imgur.com/min/embed.js\" charset=\"utf-8\"></script>\n\n## How Does This Concept of Dimension Work?\n\nConsider the following graphs:\n\n- ![2D Sphäre im\nGitter](https://writings.stephenwolfram.com/data/uploads/2020/04/0414img31.png \"fig:\")\n- ![3D Sphäre im\nGitter](https://writings.stephenwolfram.com/data/uploads/2020/04/0414img32.png \"fig:\")\n\nBoth demonstrate how spheres spread in a lattice. According to Wolfram, this is formed by: \"Start at some point in the hypergraph. Then follow $r$ hyperedges in all possible ways. You've effectively made the analog of a 'spherical ball' in the hypergraph.\"[^1]\n\nFor any graph, one can choose a point and count how many points are reachable within $r$ steps or fewer. If this spread resembles that of a polynomial, the degree can determine the dimension. However, determining the exact dimension is not trivial and is explained more thoroughly[^3] [^4] in Chapter 4.6 of the Wolfram Physics Project[^2].\n\n## Calculation of Dimension\n\n### Note\n\nThe following considers a version developed by me, which is inspired by the original.\n\n### Calculation\n\nLet $(M,d)$ be a metric space.\n\n$M$ is the set.\n$d: M\\times M \\rightarrow \\mathbb{R}_{\\ge 0}$ is a metric.\nLet $V_{r,x} = |{y \\in M \\mid d(x,y) \\le r}|$ be the number of points in a ball with radius $r$.\n\nLet $\\Delta_{r,x} = \\frac{\\log(V_{r+1,x})-\\log(V_{r,x})}{\\log(r+1)-\\log(r)} = \\frac{\\log\\frac{V_{r+1,x}}{V_{r,x}}}{\\log{\\frac{r+1}{r}}}$.\n\nNow, the following applies:\n\n$$\n\\text{dim}(M,d) = \\begin{cases}\n\\lim_{r\\rightarrow \\infty}\\Delta_{r,x} & \\text{if}\\> |M|\\ge\\infty \\wedge |V_{r,x}|<\\infty\\\\\\\\\\\\\\\\\n\\lim_{r\\rightarrow \\infty}\\Delta_{r,x} & \\text{(?) if}\\> |M|\\ge\\infty \\wedge |V_{r,x}|\\ge\\infty\\\\\\\\\\\\\\\\\n\\begin{gather}\nv\\in\\mathbb{R}_{\\ge 0} \\text{ with } \\\\\\\\\\\\\\\\\n|\\{\\Delta_{v\\pm\\epsilon,x}\\}| = \\max |\\{\\Delta_{w\\pm\\epsilon,x}\\}|\\\\\\\\\\\\\\\\\n\\forall \\epsilon,w\\in\\mathbb{R}_{\\ge 0}\n\\end{gather} & \\text{if}\\> |M|<\\infty\n\\end{cases}\n$$\n\n### Example 1\n\n$$\n\\begin{aligned}\n    M      & = \\mathbb{Z}^2 \\\\\\\\\\\\\\\\\n    d(x,y) & = |x_1+y_1 + x_2+y_2| \\\\\\\\\\\\\\\\\n    V_{r,x}& = 2r^2+2r+1 \\quad\\forall x\\in M\\\\\\\\\\\\\\\\\n    \\Delta_{r,x} &= \\frac{\\log{\\left(2 r + 2 \\left(r + 1\\right)^{2} + 3 \\right)} - \\log{\\left(2 r^{2} + 2 r + 1 \\right)}}{- \\log{\\left(r \\right)} + \\log{\\left(r + 1 \\right)}} \\\\\\\\\\\\\\\\\n    \\lim_{r\\rightarrow\\infty}\\Delta_{r,x} &= 2\n\\end{aligned}\n$$\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nV = lambda r: 2*r**2+2*r+1\nDelta = lambda r: (np.log(V(r+1))-np.log(V(r)))/(np.log(r+1)-np.log(r))\nxn = np.arange(0.1, 100,1)\nfig, ax = plt.subplots()\nax.plot(xn, Delta(xn))\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-2-output-1.png){width=571 height=411}\n:::\n:::\n\n\n### Example 2\n\n$$\n\\begin{aligned}\n    M      & = \\mathbb{Z}^2 \\\\\\\\\\\\\\\\\n    d(x,y) & = |x_1+y_1 + x_2+y_2| \\\\\\\\\\\\\\\\\n    V_{r,x}& = 2r^2+2r+1 \\quad\\forall x\\in M\\\\\\\\\\\\\\\\\n    \\Delta_{r,x} &= \\frac{\\log{\\left(2 r + 2 \\left(r + 1\\right)^{2} + 3 \\right)} - \\log{\\left(2 r^{2} + 2 r + 1 \\right)}}{- \\log{\\left(r \\right)} + \\log{\\left(r + 1 \\right)}} \\\\\\\\\\\\\\\\\n    \\lim_{r\\rightarrow\\infty}\\Delta_{r,x} &= 2\n\\end{aligned}\n$$\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\nV = lambda r: 2*r**2+2*r+1\nDelta = lambda r: (np.log(V(r+1))-np.log(V(r)))/(np.log(r+1)-np.log(r))\nxn = np.arange(0.1, 100,1)\nfig, ax = plt.subplots()\nax.plot(xn, Delta(xn))\nax.grid()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-3-output-1.png){width=571 height=411}\n:::\n:::\n\n\n### Example 3\n\nThe Sierpiński-Triangle is a fractal with a dimension of $\\log(3)/\\log(2)$. The following code calculates the dimension of the Sierpiński-Triangle.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nsirp = lambda x: [[],[],[]] if x==[] else [ sirp(v) for v in x]\nrepeat = lambda f,x,n: f(x) if n==1 else f(repeat(f,x,n-1))\npoints = []\nstart  = np.array([1,1])\nangle  = 2*np.pi/3       # Winkel zwischen Punkten\nlength = 1               # Anfangslänge eines Punktes zum nächsten\ndecay  = 0.5             # Koeffizient, mit dem bei jeder Iterationstiefe die Länge zwischen Punkten sinkt\ndef calc(data, current_point=start, length=length):\n    if len(data)==0:\n        points.append(current_point)\n    for i in range(len(data)):\n        newpoint = current_point+np.array([\n            length * np.cos(angle * i),\n            length * np.sin(angle * i),\n        ])\n        calc(data[i], newpoint, length*decay)\n\n# Sierpiński Dreieck mit Rekursionstiefe rt\nrt = 6\ndata = repeat(sirp, [], rt)\ncalc(data)\n\n# Zeichnen\nx, y = np.array(points).T\nfig, ax = plt.subplots()\nax.scatter(x, y, s=1)\nplt.legend(['Ein Sierpiński Dreieck mit Rekursionstiefe $'+str(rt)+'$'])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-4-output-1.png){width=582 height=411}\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nrn = np.arange(0.1,2,0.025)\nd = np.hypot\nU = lambda r,p: [ q for q in points if d(*(p-q))<=r ]\nV = lambda r,p: len(U(r,p))\ndef avg(r):\n    \"\"\"berechne die durchschnittliche Anzahl an Punkten in einer r großen Umgebung\n    \"\"\"\n    total = 0\n    for p in points:\n        total += V(r,p)\n    total /= len(points)\n    return total\n\nval = [avg(r) for r in rn]\nfig, ax = plt.subplots()\nax.plot(rn, val)\nplt.xlabel('Radius $r$')\nplt.legend(['Durchschnittliche Anzahl an Punkten in $V_r$'])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-1.png){width=575 height=429}\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndn = [rn[i] for i in range(1,len(rn)-1)]\nDelta = lambda i: (np.log(val[i+1])-np.log(val[i]))/(np.log(rn[i+1])-np.log(rn[i]))\ndval = [Delta(i) for i in range(len(dn))]\n\nfig, ax = plt.subplots()\nax.plot(dn, dval)\nax.plot(dn, [np.log2(3) for _ in dn], '.:')\nplt.xlabel('Radius $r$')\nplt.ylabel('$\\Delta_r$')\nplt.legend(['Durchschnittliches $\\Delta_r$', 'Hausdorff Dimension von Sierpiński-Dreieck$\\approx\\log_2(3)$'])\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n<matplotlib.legend.Legend at 0x7fff2dddc650>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nError in callback <function _draw_all_if_interactive at 0x7fffcf4d8180> (for post_execute), with arguments args (),kwargs {}:\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nValueError: \nHausdorff Dimension von Sierpiński-Dreieck$\u0007pprox\\log_2(3)$\n                                          ^\nParseException: Expected end of text, found '$'  (at char 42), (line:1, col:43)\n```\n:::\n\n::: {.cell-output .cell-output-error}\n```\nValueError: \nHausdorff Dimension von Sierpiński-Dreieck$\u0007pprox\\log_2(3)$\n                                          ^\nParseException: Expected end of text, found '$'  (at char 42), (line:1, col:43)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```\n<Figure size 672x480 with 1 Axes>\n```\n:::\n:::\n\n\n[^1]: <https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#23_out>\n[^2]: <https://www.wolframphysics.org/>\n[^3]: <https://www.wolframphysics.org/technical-introduction/limiting-behavior-and-emergent-geometry/the-notion-of-dimension/>\n[^4]: <https://www.wolframphysics.org/technical-introduction/limiting-behavior-and-emergent-geometry/dimension-related-characterizations/>\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}